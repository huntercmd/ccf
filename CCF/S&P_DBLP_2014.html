 
<head>
<meta name="HunterCmd" charset="utf-8">

<link href="../config/font-awesome-4.3.0/css/font-awesome.min.css" rel="stylesheet">

<link id="light" rel="stylesheet" type="text/css" href="../config/css/light.css" />  
<link id="dark" rel="stylesheet" type="text/css" href="../config/css/dark.css" disabled/>

<script src="../config/css/classie.js"></script>


<!-- This is for Mathjax -->

<script type="text/javascript"
  src="../config/mathjax2.2/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>

<script type="text/x-mathjax-config">
	MathJax.Hub.Config({
		tex2jax: {
			inlineMath: [ ['$','$'], ["$","$"] ],
			displayMath: [ ['$$','$$'], ["$$","$$"] ],
			processEscapes: true
			},
		TeX: {equationNumbers: {autoNumber: ["AMS"], useLabelIds: true}},
		"HTML-CSS": {linebreaks: {automatic: true}},
		SVG: {linebreaks: {automatic: true}}
	});
</script>

<title>HunterCmd</title>
</head>

<body class="cbp-spmenu-push">

<nav class="cbp-spmenu cbp-spmenu-vertical cbp-spmenu-left" id="menu-s1" style="width: 320px;overflow: auto;
">

<h1>Table of contents</h1>
<ul>
<li><a href="#35. S&P 2014:Berkeley, California, USA">35. S&amp;P 2014:Berkeley, California, USA</a><ul>
<li><a href="#Paper Num: 44 || Session Num: 12">Paper Num: 44 || Session Num: 12</a></li>
<li><a href="#Session 1: Attacks 1    4">Session 1: Attacks 1    4</a><ul>
<li><a href="#1. Hunting the Red Fox Online: Understanding and Detection of Mass Redirect-Script Injections.">1. Hunting the Red Fox Online: Understanding and Detection of Mass Redirect-Script Injections.</a></li>
<li><a href="#2. Stealing Webpages Rendered on Your Browser by Exploiting GPU Vulnerabilities.">2. Stealing Webpages Rendered on Your Browser by Exploiting GPU Vulnerabilities.</a></li>
<li><a href="#3. All Your Screens Are Belong to Us: Attacks Exploiting the HTML5 Screen Sharing API.">3. All Your Screens Are Belong to Us: Attacks Exploiting the HTML5 Screen Sharing API.</a></li>
<li><a href="#4. Chip and Skim: Cloning EMV Cards with the Pre-play Attack.">4. Chip and Skim: Cloning EMV Cards with the Pre-play Attack.</a></li>
</ul>
</li>
<li><a href="#Session 2: SSL/TLS    4">Session 2: SSL/TLS    4</a><ul>
<li><a href="#5. When HTTPS Meets CDN: A Case of Authentication in Delegated Service.">5. When HTTPS Meets CDN: A Case of Authentication in Delegated Service.</a></li>
<li><a href="#6. Analyzing Forged SSL Certificates in the Wild.">6. Analyzing Forged SSL Certificates in the Wild.</a></li>
<li><a href="#7. Triple Handshakes and Cookie Cutters: Breaking and Fixing Authentication over TLS.">7. Triple Handshakes and Cookie Cutters: Breaking and Fixing Authentication over TLS.</a></li>
<li><a href="#8. Using Frankencerts for Automated Adversarial Testing of Certificate Validation in SSL/TLS Implementations.">8. Using Frankencerts for Automated Adversarial Testing of Certificate Validation in SSL/TLS Implementations.</a></li>
</ul>
</li>
<li><a href="#Session 3: Automation    4">Session 3: Automation    4</a><ul>
<li><a href="#9. Automating Isolation and Least Privilege in Web Services.">9. Automating Isolation and Least Privilege in Web Services.</a></li>
<li><a href="#10. Hidden GEMs: Automated Discovery of Access Control Vulnerabilities in Graphical User Interfaces.">10. Hidden GEMs: Automated Discovery of Access Control Vulnerabilities in Graphical User Interfaces.</a></li>
<li><a href="#11. Automated Analysis of Security Protocols with Global State.">11. Automated Analysis of Security Protocols with Global State.</a></li>
<li><a href="#12. Automated Verification of Group Key Agreement Protocols.">12. Automated Verification of Group Key Agreement Protocols.</a></li>
</ul>
</li>
<li><a href="#Session 4: Attacks 2    4">Session 4: Attacks 2    4</a><ul>
<li><a href="#13. Practical Evasion of a Learning-Based Classifier: A Case Study.">13. Practical Evasion of a Learning-Based Classifier: A Case Study.</a></li>
<li><a href="#14. Doppelgänger Finder: Taking Stylometry to the Underground.">14. Doppelgänger Finder: Taking Stylometry to the Underground.</a></li>
<li><a href="#15. Hacking Blind.">15. Hacking Blind.</a></li>
<li><a href="#16. Framing Signals - A Return to Portable Shellcode.">16. Framing Signals - A Return to Portable Shellcode.</a></li>
</ul>
</li>
<li><a href="#Session 5: Systems Security    4">Session 5: Systems Security    4</a><ul>
<li><a href="#17. Pivot: Fast, Synchronous Mashup Isolation Using Generator Chains.">17. Pivot: Fast, Synchronous Mashup Isolation Using Generator Chains.</a></li>
<li><a href="#18. SoK: Automated Software Diversity.">18. SoK: Automated Software Diversity.</a></li>
<li><a href="#19. KCoFI: Complete Control-Flow Integrity for Commodity Operating System Kernels.">19. KCoFI: Complete Control-Flow Integrity for Commodity Operating System Kernels.</a></li>
<li><a href="#20. Dancing with Giants: Wimpy Kernels for On-Demand Isolated I/O.">20. Dancing with Giants: Wimpy Kernels for On-Demand Isolated I/O.</a></li>
</ul>
</li>
<li><a href="#Session 6: Privacy and Anonymity    4">Session 6: Privacy and Anonymity    4</a><ul>
<li><a href="#21. Bootstrapping Privacy Compliance in Big Data Systems.">21. Bootstrapping Privacy Compliance in Big Data Systems.</a></li>
<li><a href="#22. Formal Analysis of Chaumian Mix Nets with Randomized Partial Checking.">22. Formal Analysis of Chaumian Mix Nets with Randomized Partial Checking.</a></li>
<li><a href="#23. Blind Seer: A Scalable Private DBMS.">23. Blind Seer: A Scalable Private DBMS.</a></li>
<li><a href="#24. ANONIZE: A Large-Scale Anonymous Survey System.">24. ANONIZE: A Large-Scale Anonymous Survey System.</a></li>
</ul>
</li>
<li><a href="#Session 7: Android    3">Session 7: Android    3</a><ul>
<li><a href="#25. Upgrading Your Android, Elevating My Malware: Privilege Escalation through Mobile OS Updating.">25. Upgrading Your Android, Elevating My Malware: Privilege Escalation through Mobile OS Updating.</a></li>
<li><a href="#26. The Peril of Fragmentation: Security Hazards in Android Device Driver Customizations.">26. The Peril of Fragmentation: Security Hazards in Android Device Driver Customizations.</a></li>
<li><a href="#27. From Zygote to Morula: Fortifying Weakened ASLR on Android.">27. From Zygote to Morula: Fortifying Weakened ASLR on Android.</a></li>
</ul>
</li>
<li><a href="#Session 8: E-Cash    3">Session 8: E-Cash    3</a><ul>
<li><a href="#28. Secure Multiparty Computations on Bitcoin.">28. Secure Multiparty Computations on Bitcoin.</a></li>
<li><a href="#29. Zerocash: Decentralized Anonymous Payments from Bitcoin.">29. Zerocash: Decentralized Anonymous Payments from Bitcoin.</a></li>
<li><a href="#30. Permacoin: Repurposing Bitcoin Work for Data Preservation.">30. Permacoin: Repurposing Bitcoin Work for Data Preservation.</a></li>
</ul>
</li>
<li><a href="#Session 8: Miscellaneous    4">Session 8: Miscellaneous    4</a><ul>
<li><a href="#31. Cloak and Swagger: Understanding Data Sensitivity through the Lens of User Anonymity.">31. Cloak and Swagger: Understanding Data Sensitivity through the Lens of User Anonymity.</a></li>
<li><a href="#32. Stopping a Rapid Tornado with a Puff.">32. Stopping a Rapid Tornado with a Puff.</a></li>
<li><a href="#33. SoK: Security and Privacy in Implantable Medical Devices and Body Area Networks.">33. SoK: Security and Privacy in Implantable Medical Devices and Body Area Networks.</a></li>
<li><a href="#34. Quantifying Information Flow for Dynamic Secrets.">34. Quantifying Information Flow for Dynamic Secrets.</a></li>
</ul>
</li>
<li><a href="#Session 9: Attacks 3    4">Session 9: Attacks 3    4</a><ul>
<li><a href="#35. Not-So-Random Numbers in Virtualized Linux and the Whirlwind RNG.">35. Not-So-Random Numbers in Virtualized Linux and the Whirlwind RNG.</a></li>
<li><a href="#36. Out of Control: Overcoming Control-Flow Integrity.">36. Out of Control: Overcoming Control-Flow Integrity.</a></li>
<li><a href="#37. Modeling and Discovering Vulnerabilities with Code Property Graphs.">37. Modeling and Discovering Vulnerabilities with Code Property Graphs.</a></li>
<li><a href="#38. SoK: Introspections on Trust and the Semantic Gap.">38. SoK: Introspections on Trust and the Semantic Gap.</a></li>
</ul>
</li>
<li><a href="#Session 10: Secure Computation and Storage    3">Session 10: Secure Computation and Storage    3</a><ul>
<li><a href="#39. Automating Efficient RAM-Model Secure Computation.">39. Automating Efficient RAM-Model Secure Computation.</a></li>
<li><a href="#40. Dynamic Searchable Encryption via Blind Storage.">40. Dynamic Searchable Encryption via Blind Storage.</a></li>
<li><a href="#41. Wysteria: A Programming Language for Generic, Mixed-Mode Multiparty Computations.">41. Wysteria: A Programming Language for Generic, Mixed-Mode Multiparty Computations.</a></li>
</ul>
</li>
<li><a href="#Session 11: Authentication    3">Session 11: Authentication    3</a><ul>
<li><a href="#42. An Expressive Model for the Web Infrastructure: Definition and Application to the Browser ID SSO System.">42. An Expressive Model for the Web Infrastructure: Definition and Application to the Browser ID SSO System.</a></li>
<li><a href="#43. A Study of Probabilistic Password Models.">43. A Study of Probabilistic Password Models.</a></li>
<li><a href="#44. ZEBRA: Zero-Effort Bilateral Recurring Authentication.">44. ZEBRA: Zero-Effort Bilateral Recurring Authentication.</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav><h1 id="35. S&P 2014:Berkeley, California, USA">35. S&amp;P 2014:Berkeley, California, USA</h1>
<p><a href="http://ieeexplore.ieee.org/xpl/mostRecentIssue.jsp?punumber=6954656">2014 IEEE Symposium on Security and Privacy, SP 2014, Berkeley, CA, USA, May 18-21, 2014.</a> IEEE Computer Society
【<a href="http://dblp.uni-trier.de/db/conf/sp/sp2014.html">DBLP Link</a>】</p>
<h2 id="Paper Num: 44 || Session Num: 12">Paper Num: 44 || Session Num: 12</h2>
<h2 id="Session 1: Attacks 1    4">Session 1: Attacks 1    4</h2>
<h3 id="1. Hunting the Red Fox Online: Understanding and Detection of Mass Redirect-Script Injections.">1. Hunting the Red Fox Online: Understanding and Detection of Mass Redirect-Script Injections.</h3>
<p>【<a href="http://dx.doi.org/10.1109/SP.2014.8">Paper Link</a>】    【Pages】:3-18</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/l/Li:Zhou">Zhou Li</a> ; <a href="http://dblp.uni-trier.de/pers/hd/a/Alrwais:Sumayah_A=">Sumayah A. Alrwais</a> ; <a href="http://dblp.uni-trier.de/pers/hd/w/Wang:XiaoFeng">XiaoFeng Wang</a> ; <a href="http://dblp.uni-trier.de/pers/hd/a/Alowaisheq:Eihal">Eihal Alowaisheq</a></p>
<p>【Abstract】:
Compromised websites that redirect web traffic to malicious hosts play a critical role in organized web crimes, serving as doorways to all kinds of malicious web activities (e.g., drive-by downloads, phishing etc.). They are also among the most elusive components of a malicious web infrastructure and extremely difficult to hunt down, due to the simplicity of redirect operations, which also happen on legitimate sites, and extensive use of cloaking techniques. Making the detection even more challenging is the recent trend of injecting redirect scripts into JavaScript (JS) files, as those files are not indexed by search engines and their infections are therefore more difficult to catch. In our research, we look at the problem from a unique angle: the adversary's strategy and constraints for deploying redirect scripts quickly and stealthily. Specifically, we found that such scripts are often blindly injected into both JS and HTML files for a rapid deployment, changes to the infected JS files are often made minimum to evade detection and also many JS files are actually JS libraries (JS-libs) whose uninfected versions are publicly available. Based upon those observations, we developed JsRED, a new technique for the automatic detection of unknown redirect-script injections. Our approach analyzes the difference between a suspicious JS-lib file and its clean counterpart to identify malicious redirect scripts and further searches for similar scripts in other JS and HTML files. This simple, lightweight approach is found to work effectively against redirect injection campaigns: our evaluation shows that JsRED captured most of compromised websites with almost no false positives, significantly outperforming a commercial detection service in terms of finding unknown JS infections. Based upon the compromised websites reported by JsRED, we further conducted a measurement study that reveals interesting features of redirect payloads and a new Peer-to-Peer network the adversary const- ucted to evade detection.</p>
<p>【Keywords】:
 Internet; Java; Web sites; authoring languages; hypermedia markup languages; peer-to-peer computing; security of data; HTML files; JS files; JavaScript; JsRED; Web sites; malicious Web infrastructure; peer-to-peer network; redirect-script injection detection; Browsers; Feeds; HTML; Libraries; Payloads; Security; Servers; Compromised Web Sites; Differential Analysis; Web Redirection</p>
<h3 id="2. Stealing Webpages Rendered on Your Browser by Exploiting GPU Vulnerabilities.">2. Stealing Webpages Rendered on Your Browser by Exploiting GPU Vulnerabilities.</h3>
<p>【<a href="http://dx.doi.org/10.1109/SP.2014.9">Paper Link</a>】    【Pages】:19-33</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/l/Lee_0001:Sangho">Sangho Lee</a> ; <a href="http://dblp.uni-trier.de/pers/hd/k/Kim:Youngsok">Youngsok Kim</a> ; <a href="http://dblp.uni-trier.de/pers/hd/k/Kim:Jangwoo">Jangwoo Kim</a> ; <a href="http://dblp.uni-trier.de/pers/hd/k/Kim:Jong">Jong Kim</a></p>
<p>【Abstract】:
Graphics processing units (GPUs) are important components of modern computing devices for not only graphics rendering, but also efficient parallel computations. However, their security problems are ignored despite their importance and popularity. In this paper, we first perform an in-depth security analysis on GPUs to detect security vulnerabilities. We observe that contemporary, widely-used GPUs, both NVIDIA's and AMD's, do not initialize newly allocated GPU memory pages which may contain sensitive user data. By exploiting such vulnerabilities, we propose attack methods for revealing a victim program's data kept in GPU memory both during its execution and right after its termination. We further show the high applicability of the proposed attacks by applying them to the Chromium and Firefox web browsers which use GPUs for accelerating webpage rendering. We detect that both browsers leave rendered webpage textures in GPU memory, so that we can infer which web pages a victim user has visited by analyzing the remaining textures. The accuracy of our advanced inference attack that uses both pixel sequence matching and RGB histogram matching is up to 95.4%.</p>
<p>【Keywords】:
 Browsers; Chromium; Context; Graphics processing units; Kernel; Memory management; Security</p>
<h3 id="3. All Your Screens Are Belong to Us: Attacks Exploiting the HTML5 Screen Sharing API.">3. All Your Screens Are Belong to Us: Attacks Exploiting the HTML5 Screen Sharing API.</h3>
<p>【<a href="http://dx.doi.org/10.1109/SP.2014.10">Paper Link</a>】    【Pages】:34-48</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/t/Tian:Yuan">Yuan Tian</a> ; <a href="http://dblp.uni-trier.de/pers/hd/l/Liu:Ying_Chuan">Ying Chuan Liu</a> ; <a href="http://dblp.uni-trier.de/pers/hd/b/Bhosale:Amar">Amar Bhosale</a> ; <a href="http://dblp.uni-trier.de/pers/hd/h/Huang:Lin=Shung">Lin-Shung Huang</a> ; <a href="http://dblp.uni-trier.de/pers/hd/t/Tague:Patrick">Patrick Tague</a> ; <a href="http://dblp.uni-trier.de/pers/hd/j/Jackson:Collin">Collin Jackson</a></p>
<p>【Abstract】:
HTML5 changes many aspects in the browser world by introducing numerous new concepts, in particular, the new HTML5 screen sharing API impacts the security implications of browsers tremendously. One of the core assumptions on which browser security is built is that there is no cross-origin feedback loop from the client to the server. However, the screen sharing API allows creating a cross-origin feedback loop. Consequently, websites will potentially be able to see all visible content from the user's screen, irrespective of its origin. This cross-origin feedback loop, when combined with human vision limitations, can introduce new vulnerabilities. An attacker can capture sensitive information from victim's screen using the new API without the consensus of the victim. We investigate the security implications of the screen sharing API and discuss how existing defenses against traditional web attacks fail during screen sharing. We show that several attacks are possible with the help of the screen sharing API: cross-site request forgery, history sniffing, and information stealing. We discuss how popular websites such as Amazon and Wells Fargo can be attacked using this API and demonstrate the consequences of the attacks such as economic losses, compromised account and information disclosure. The objective of this paper is to present the attacks using the screen sharing API, analyze the fundamental cause and motivate potential defenses to design a more secure screen sharing API.</p>
<p>【Keywords】:
 Web sites; application program interfaces; hypermedia markup languages; security of data; HTML5 screen sharing API; Web attacks; Web sites; history sniffing; information stealing; Browsers; Feedback loop; Google; History; Receivers; Security; Servers; Browser Security; HTML5; Screen Sharing</p>
<h3 id="4. Chip and Skim: Cloning EMV Cards with the Pre-play Attack.">4. Chip and Skim: Cloning EMV Cards with the Pre-play Attack.</h3>
<p>【<a href="http://dx.doi.org/10.1109/SP.2014.11">Paper Link</a>】    【Pages】:49-64</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/b/Bond:Mike">Mike Bond</a> ; <a href="http://dblp.uni-trier.de/pers/hd/c/Choudary:Omar">Omar Choudary</a> ; <a href="http://dblp.uni-trier.de/pers/hd/m/Murdoch:Steven_J=">Steven J. Murdoch</a> ; <a href="http://dblp.uni-trier.de/pers/hd/s/Skorobogatov:Sergei_P=">Sergei P. Skorobogatov</a> ; <a href="http://dblp.uni-trier.de/pers/hd/a/Anderson:Ross_J=">Ross J. Anderson</a></p>
<p>【Abstract】:
EMV, also known as "Chip and PIN", is the leading system for card payments worldwide. It is used throughout Europe and much of Asia, and is starting to be introduced in North America too. Payment cards contain a chip so they can execute an authentication protocol. This protocol requires point-of-sale (POS) terminals or ATMs to generate a nonce, called the unpredictable number, for each transaction to ensure it is fresh. We have discovered two serious problems: a widespread implementation flaw and a deeper, more difficult to fix flaw with the EMV protocol itself. The first flaw is that some EMV implementers have merely used counters, timestamps or home-grown algorithms to supply this nonce. This exposes them to a "pre-play" attack which is indistinguishable from card cloning from the standpoint of the logs available to the card-issuing bank, and can be carried out even if it is impossible to clone a card physically. Card cloning is the very type of fraud that EMV was supposed to prevent. We describe how we detected the vulnerability, a survey methodology we developed to chart the scope of the weakness, evidence from ATM and terminal experiments in the field, and our implementation of proof-of-concept attacks. We found flaws in widely-used ATMs from the largest manufacturers. We can now explain at least some of the increasing number of frauds in which victims are refused refunds by banks which claim that EMV cards cannot be cloned and that a customer involved in a dispute must therefore be mistaken or complicit. The second problem was exposed by the above work. Independent of the random number quality, there is a protocol failure: the actual random number generated by the terminal can simply be replaced by one the attacker used earlier when capturing an authentication code from the card. This variant of the pre-play attack may be carried out by malware in an ATM or POS terminal, or by a man-in-the-middle between the terminal and the acquirer. We explore the design an- implementation mistakes that enabled these flaws to evade detection until now: shortcomings of the EMV specification, of the EMV kernel certification process, of implementation testing, formal analysis, and monitoring customer complaints. Finally we discuss countermeasures. More than a year after our initial responsible disclosure of these flaws to the banks, action has only been taken to mitigate the first of them, while we have seen a likely case of the second in the wild, and the spread of ATM and POS malware is making it ever more of a threat.</p>
<p>【Keywords】:
 financial data processing; invasive software; ATM malware; Asia; EMV card cloning; Europe; North America; POS malware; POS terminals; automated teller machines; card payments; counters; home-grown algorithms; man-in-the-middle attack; point-of-sale terminals; preplay attack; proof-of-concept attacks; timestamps; unpredictable number; Authentication; Authorization; Cloning; Cryptography; Online banking; Protocols; Radiation detectors</p>
<h2 id="Session 2: SSL/TLS    4">Session 2: SSL/TLS    4</h2>
<h3 id="5. When HTTPS Meets CDN: A Case of Authentication in Delegated Service.">5. When HTTPS Meets CDN: A Case of Authentication in Delegated Service.</h3>
<p>【<a href="http://dx.doi.org/10.1109/SP.2014.12">Paper Link</a>】    【Pages】:67-82</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/l/Liang:Jinjin">Jinjin Liang</a> ; <a href="http://dblp.uni-trier.de/pers/hd/j/Jiang:Jian">Jian Jiang</a> ; <a href="http://dblp.uni-trier.de/pers/hd/d/Duan:Hai=Xin">Hai-Xin Duan</a> ; <a href="http://dblp.uni-trier.de/pers/hd/l/Li:Kang">Kang Li</a> ; <a href="http://dblp.uni-trier.de/pers/hd/w/Wan:Tao">Tao Wan</a> ; <a href="http://dblp.uni-trier.de/pers/hd/w/Wu:Jianping">Jianping Wu</a></p>
<p>【Abstract】:
Content Delivery Network (CDN) and Hypertext Transfer Protocol Secure (HTTPS) are two popular but independent web technologies, each of which has been well studied individually and independently. This paper provides a systematic study on how these two work together. We examined 20 popular CDN providers and 10,721 of their customer web sites using HTTPS. Our study reveals various problems with the current HTTPS practice adopted by CDN providers, such as widespread use of invalid certificates, private key sharing, neglected revocation of stale certificates, and insecure back-end communication. While some of those problems are operational issues only, others are rooted in the fundamental semantic conflict between the end-to-end nature of HTTPS and the man-in-the-middle nature of CDN involving multiple parties in a delegated service. To address the delegation problem when HTTPS meets CDN, we proposed and implemented a lightweight solution based on DANE (DNS-based Authentication of Named Entities), an emerging IETF protocol complementing the current Web PKI model. Our implementation demonstrates that it is feasible for HTTPS to work with CDN securely and efficiently. This paper intends to provide a context for future discussion within security and CDN community on more preferable solutions.</p>
<p>【Keywords】:
 Internet; computer network security; protocols; CDN; DANE protocol; DNS-based authentication of named entities; HTTPS; Web technology; content delivery network; delegated service authentication; domain name system; hypertext transfer protocol secure; stale certificates; Authentication; Browsers; Protocols; Servers; Uniform resource locators</p>
<h3 id="6. Analyzing Forged SSL Certificates in the Wild.">6. Analyzing Forged SSL Certificates in the Wild.</h3>
<p>【<a href="http://dx.doi.org/10.1109/SP.2014.13">Paper Link</a>】    【Pages】:83-97</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/h/Huang:Lin=Shung">Lin-Shung Huang</a> ; <a href="http://dblp.uni-trier.de/pers/hd/r/Rice:Alex">Alex Rice</a> ; <a href="http://dblp.uni-trier.de/pers/hd/e/Ellingsen:Erling">Erling Ellingsen</a> ; <a href="http://dblp.uni-trier.de/pers/hd/j/Jackson:Collin">Collin Jackson</a></p>
<p>【Abstract】:
The SSL man-in-the-middle attack uses forged SSL certificates to intercept encrypted connections between clients and servers. However, due to a lack of reliable indicators, it is still unclear how commonplace these attacks occur in the wild. In this work, we have designed and implemented a method to detect the occurrence of SSL man-in-the-middle attack on a top global website, Facebook. Over 3 million real-world SSL connections to this website were analyzed. Our results indicate that 0.2% of the SSL connections analyzed were tampered with forged SSL certificates, most of them related to antivirus software and corporate-scale content filters. We have also identified some SSL connections intercepted by malware. Limitations of the method and possible defenses to such attacks are also discussed.</p>
<p>【Keywords】:
 certification; security of data; Facebook; SSL man-in-the-middle attack; antivirus software; corporate-scale content filters; encrypted connections; forged SSL certificate analysis; global Web site; secure socket layer; Browsers; Cryptography; Java; Protocols; Servers; Sockets; SSL; certificates; man-in-the-middle attack</p>
<h3 id="7. Triple Handshakes and Cookie Cutters: Breaking and Fixing Authentication over TLS.">7. Triple Handshakes and Cookie Cutters: Breaking and Fixing Authentication over TLS.</h3>
<p>【<a href="http://dx.doi.org/10.1109/SP.2014.14">Paper Link</a>】    【Pages】:98-113</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/b/Bhargavan:Karthikeyan">Karthikeyan Bhargavan</a> ; <a href="http://dblp.uni-trier.de/pers/hd/d/Delignat=Lavaud:Antoine">Antoine Delignat-Lavaud</a> ; <a href="http://dblp.uni-trier.de/pers/hd/f/Fournet:C=eacute=dric">Cédric Fournet</a> ; <a href="http://dblp.uni-trier.de/pers/hd/p/Pironti:Alfredo">Alfredo Pironti</a> ; <a href="http://dblp.uni-trier.de/pers/hd/s/Strub:Pierre=Yves">Pierre-Yves Strub</a></p>
<p>【Abstract】:
TLS was designed as a transparent channel abstraction to allow developers with no cryptographic expertise to protect their application against attackers that may control some clients, some servers, and may have the capability to tamper with network connections. However, the security guarantees of TLS fall short of those of a secure channel, leading to a variety of attacks. We show how some widespread false beliefs about these guarantees can be exploited to attack popular applications and defeat several standard authentication methods that rely too naively on TLS. We present new client impersonation attacks against TLS renegotiations, wireless networks, challenge-response protocols, and channel-bound cookies. Our attacks exploit combinations of RSA and Diffie-Hellman key exchange, session resumption, and renegotiation to bypass many recent countermeasures. We also demonstrate new ways to exploit known weaknesses of HTTP over TLS. We investigate the root causes for these attacks and propose new countermeasures. At the protocol level, we design and implement two new TLS extensions that strengthen the authentication guarantees of the handshake. At the application level, we develop an exemplary HTTPS client library that implements several mitigations, on top of a previously verified TLS implementation, and verify that their composition provides strong, simple application security.</p>
<p>【Keywords】:
 authorisation; client-server systems; computer network security; cryptographic protocols; data protection; public key cryptography; transport protocols; Diffie-Hellman key exchange; HTTPS client library; RSA; TLS implementation; TLS renegotiations; TLS security guarantees; application protection; application security; authentication; challenge-response protocols; channel-bound cookies; client impersonation attacks; cookie cutters; network connections; secure channel; session resumption; transparent channel abstraction; triple-handshakes; wireless networks; Authentication; Browsers; Cryptography; Libraries; Protocols; Servers</p>
<h3 id="8. Using Frankencerts for Automated Adversarial Testing of Certificate Validation in SSL/TLS Implementations.">8. Using Frankencerts for Automated Adversarial Testing of Certificate Validation in SSL/TLS Implementations.</h3>
<p>【<a href="http://dx.doi.org/10.1109/SP.2014.15">Paper Link</a>】    【Pages】:114-129</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/b/Brubaker:Chad">Chad Brubaker</a> ; <a href="http://dblp.uni-trier.de/pers/hd/j/Jana:Suman">Suman Jana</a> ; <a href="http://dblp.uni-trier.de/pers/hd/r/Ray:Baishakhi">Baishakhi Ray</a> ; <a href="http://dblp.uni-trier.de/pers/hd/k/Khurshid:Sarfraz">Sarfraz Khurshid</a> ; <a href="http://dblp.uni-trier.de/pers/hd/s/Shmatikov:Vitaly">Vitaly Shmatikov</a></p>
<p>【Abstract】:
Modern network security rests on the Secure Sockets Layer (SSL) and Transport Layer Security (TLS) protocols. Distributed systems, mobile and desktop applications, embedded devices, and all of secure Web rely on SSL/TLS for protection against network attacks. This protection critically depends on whether SSL/TLS clients correctly validate X.509 certificates presented by servers during the SSL/TLS handshake protocol. We design, implement, and apply the first methodology for large-scale testing of certificate validation logic in SSL/TLS implementations. Our first ingredient is "frankencerts," synthetic certificates that are randomly mutated from parts of real certificates and thus include unusual combinations of extensions and constraints. Our second ingredient is differential testing: if one SSL/TLS implementation accepts a certificate while another rejects the same certificate, we use the discrepancy as an oracle for finding flaws in individual implementations. Differential testing with frankencerts uncovered 208 discrepancies between popular SSL/TLS implementations such as OpenSSL, NSS, CyaSSL, GnuTLS, PolarSSL, MatrixSSL, etc. Many of them are caused by serious security vulnerabilities. For example, any server with a valid X.509 version1 certificate can act as a rogue certificate authority and issue fake certificates for any domain, enabling man-in-the-middle attacks against MatrixSSL and GnuTLS. Several implementations also accept certificate authorities created by unauthorized issuers, as well as certificates not intended for server authentication. We also found serious vulnerabilities in how users are warned about certificate validation errors. When presented with an expired, self-signed certificate, NSS, Safari, and Chrome (on Linux) report that the certificate has expired - a low-risk, often ignored error - but not that the connection is insecure against a man-in-the-middle attack. These results demonstrate that automated adversarial testing with frankencert- is a powerful methodology for discovering security flaws in SSL/TLS implementations.</p>
<p>【Keywords】:
 authorisation; computer network security; online front-ends; protocols; Chrome; CyaSSL; Frankencerts; GnuTLS; MatrixSSL; NSS; OpenSSL; PolarSSL; SSL-TLS clients; SSL-TLS handshake protocol; SSL-TLS implementations; Safari; X.509 certificates; automated adversarial testing; certificate validation errors; certificate validation logic; differential testing; man-in-the-middle attacks; modern network security; network attacks; oracle; secure sockets layer protocols; security vulnerabilities; self-signed certificate; server authentication; synthetic certificates; transport layer security protocols; Authentication; Browsers; Computer bugs; Protocols; Servers; Testing; SSL; automated testing; certificate validation</p>
<h2 id="Session 3: Automation    4">Session 3: Automation    4</h2>
<h3 id="9. Automating Isolation and Least Privilege in Web Services.">9. Automating Isolation and Least Privilege in Web Services.</h3>
<p>【<a href="http://dx.doi.org/10.1109/SP.2014.16">Paper Link</a>】    【Pages】:133-148</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/b/Blankstein:Aaron">Aaron Blankstein</a> ; <a href="http://dblp.uni-trier.de/pers/hd/f/Freedman:Michael_J=">Michael J. Freedman</a></p>
<p>【Abstract】:
In many client-facing applications, a vulnerability in any part can compromise the entire application. This paper describes the design and implementation of Passe, a system that protects a data store from unintended data leaks and unauthorized writes even in the face of application compromise. Passe automatically splits (previously shared-memory-space) applications into sandboxed processes. Passe limits communication between those components and the types of accesses each component can make to shared storage, such as a backend database. In order to limit components to their least privilege, Passe uses dynamic analysis on developer-supplied end-to-end test cases to learn data and control-flow relationships between database queries and previous query results, and it then strongly enforces those relationships. Our prototype of Passe acts as a drop-in replacement for the Django web framework. By running eleven unmodified, off-the-shelf applications in Passe, we demonstrate its ability to provide strong security guarantees-Passe correctly enforced 96% of the applications' policies-with little additional overhead. Additionally, in the web-specific setting of the prototype, we also mitigate the cross-component effects of cross-site scripting (XSS) attacks by combining browser HTML5 sandboxing techniques with our automatic component separation.</p>
<p>【Keywords】:
 Web services; security of data; Django web framework; HTML5 sandboxing techniques; Passe system; Web services; XSS attack; client-facing applications; control-flow relationship; cross-site scripting attack; data-flow relationship; database queries; query results; sandboxed process; security guarantee; shared-memory-space application; Browsers; Databases; Libraries; Prototypes; Runtime; Security; Servers; capabilities; isolation; principle of least privilege; security policy inference; web security</p>
<h3 id="10. Hidden GEMs: Automated Discovery of Access Control Vulnerabilities in Graphical User Interfaces.">10. Hidden GEMs: Automated Discovery of Access Control Vulnerabilities in Graphical User Interfaces.</h3>
<p>【<a href="http://dx.doi.org/10.1109/SP.2014.17">Paper Link</a>】    【Pages】:149-162</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/m/Mulliner:Collin">Collin Mulliner</a> ; <a href="http://dblp.uni-trier.de/pers/hd/r/Robertson:William_K=">William K. Robertson</a> ; <a href="http://dblp.uni-trier.de/pers/hd/k/Kirda:Engin">Engin Kirda</a></p>
<p>【Abstract】:
Graphical user interfaces (GUIs) are the predominant means by which users interact with modern programs. GUIs contain a number of common visual elements or widgets such as labels, text fields, buttons, and lists, and GUIs typically provide the ability to set attributes on these widgets to control their visibility, enabled status, and whether they are writable. While these attributes are extremely useful to provide visual cues to users to guide them through an application's GUI, they can also be misused for purposes they were not intended. In particular, in the context of GUI-based applications that include multiple privilege levels within the application, GUI element attributes are often misused as a mechanism for enforcing access control policies. In this work, we introduce GEMs, or instances of GUI element misuse, as a novel class of access control vulnerabilities in GUI-based applications. We present a classification of different GEMs that can arise through misuse of widget attributes, and describe a general algorithm for identifying and confirming the presence of GEMs in vulnerable applications. We then present GEM Miner, an implementation of our GEM analysis for the Windows platform. We evaluate GEM Miner over a test set of three complex, real-world GUI-based applications targeted at the small business and enterprise markets, and demonstrate the efficacy of our analysis by finding numerous previously unknown access control vulnerabilities in these applications. We have reported the vulnerabilities we discovered to the developers of each application, and in one case have received confirmation of the issue.</p>
<p>【Keywords】:
 authorisation; graphical user interfaces; pattern classification; GEM Miner; GEM analysis; GEM classification; GUI element attributes; GUI element misuse; Windows platform; access control policies; access control vulnerabilities; automated discovery; business; buttons; enterprise markets; graphical user interfaces; labels; lists; real-world GUI-based applications; text fields; visual cues; visual elements; widget attributes; Licenses; Privacy; Security; GUI; access control; automation; vulnerability analysis; widget</p>
<h3 id="11. Automated Analysis of Security Protocols with Global State.">11. Automated Analysis of Security Protocols with Global State.</h3>
<p>【<a href="http://dx.doi.org/10.1109/SP.2014.18">Paper Link</a>】    【Pages】:163-178</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/k/Kremer:Steve">Steve Kremer</a> ; <a href="http://dblp.uni-trier.de/pers/hd/k/K=uuml=nnemann:Robert">Robert Künnemann</a></p>
<p>【Abstract】:
Security APIs, key servers and protocols that need to keep the status of transactions, require to maintain a global, non-monotonic state, e.g., in the form of a database or register. However, existing automated verification tools do not support the analysis of such stateful security protocols - sometimes because of fundamental reasons, such as the encoding of the protocol as Horn clauses, which are inherently monotonic. An exception is the recent tamarin prover which allows specifying protocols as multiset rewrite (MSR) rules, a formalism expressive enough to encode state. As multiset rewriting is a "low-level" specification language with no direct support for concurrent message passing, encoding protocols correctly is a difficult and error-prone process. We propose a process calculus which is a variant of the applied pi calculus with constructs for manipulation of a global state by processes running in parallel. We show that this language can be translated to MSR rules whilst preserving all security properties expressible in a dedicated first-order logic for security properties. The translation has been implemented in a prototype tool which useqs the tamarin prover as a backend. We apply the tool to several case studies among which a simplified fragment of PKCS#11, the Yubikey security token, and an optimistic contract signing protocol.</p>
<p>【Keywords】:
 Horn clauses; application program interfaces; cryptographic protocols; formal verification; message passing; pi calculus; specification languages; Horn clauses; PKCS#11; Yubikey security token; automated security protocol analysis; automated verification tools; concurrent message passing; encoding protocols; error-prone process; first-order logic; key servers; low-level specification language; msr rules; multiset rewrite rules; multiset rewriting; nonmonotonic state; optimistic contract signing protocol; pi calculus; process calculus; prototype tool; security API; security properties; tamarin prover; Analytical models; Calculus; Contracts; Mathematical model; Protocols; Security; Semantics; Multiset rewriting; Protocol Analysis; Security APIs</p>
<h3 id="12. Automated Verification of Group Key Agreement Protocols.">12. Automated Verification of Group Key Agreement Protocols.</h3>
<p>【<a href="http://dx.doi.org/10.1109/SP.2014.19">Paper Link</a>】    【Pages】:179-194</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/s/Schmidt:Benedikt">Benedikt Schmidt</a> ; <a href="http://dblp.uni-trier.de/pers/hd/s/Sasse:Ralf">Ralf Sasse</a> ; <a href="http://dblp.uni-trier.de/pers/hd/c/Cremers:Cas">Cas Cremers</a> ; <a href="http://dblp.uni-trier.de/pers/hd/b/Basin:David_A=">David A. Basin</a></p>
<p>【Abstract】:
We advance the state-of-the-art in automated symbolic cryptographic protocol analysis by providing the first algorithm that can handle Diffie-Hellman exponentiation, bilinear pairing, and AC-operators. Our support for AC-operators enables protocol specifications to use multisets, natural numbers, and finite maps. We implement the algorithm in the TAMARIN prover and provide the first symbolic correctness proofs for group key agreement protocols that use Diffie-Hellman or bilinear pairing, loops, and recursion, while at the same time supporting advanced security properties, such as perfect forward secrecy and eCK-security. We automatically verify a set of protocols, including the STR, group Joux, and GDH protocols, thereby demonstrating the effectiveness of our approach.</p>
<p>【Keywords】:
 cryptographic protocols; public key cryptography; set theory; AC-operators; Diffie-Hellman exponentiation; GDH protocols; STR; TAMARIN prover; advanced security properties; automated symbolic cryptographic protocol analysis; bilinear pairing; eCK-security; finite maps; group Joux; group key agreement protocols; multisets; natural numbers; perfect forward secrecy; protocol specifications; symbolic correctness proofs; Cognition; Cryptography; DH-HEMTs; Mathematical model; Protocols; Semantics</p>
<h2 id="Session 4: Attacks 2    4">Session 4: Attacks 2    4</h2>
<h3 id="13. Practical Evasion of a Learning-Based Classifier: A Case Study.">13. Practical Evasion of a Learning-Based Classifier: A Case Study.</h3>
<p>【<a href="http://dx.doi.org/10.1109/SP.2014.20">Paper Link</a>】    【Pages】:197-211</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/s/Srndic:Nedim">Nedim Srndic</a> ; <a href="http://dblp.uni-trier.de/pers/hd/l/Laskov:Pavel">Pavel Laskov</a></p>
<p>【Abstract】:
Learning-based classifiers are increasingly used for detection of various forms of malicious data. However, if they are deployed online, an attacker may attempt to evade them by manipulating the data. Examples of such attacks have been previously studied under the assumption that an attacker has full knowledge about the deployed classifier. In practice, such assumptions rarely hold, especially for systems deployed online. A significant amount of information about a deployed classifier system can be obtained from various sources. In this paper, we experimentally investigate the effectiveness of classifier evasion using a real, deployed system, PDFrate, as a test case. We develop a taxonomy for practical evasion strategies and adapt known evasion algorithms to implement specific scenarios in our taxonomy. Our experimental results reveal a substantial drop of PDFrate's classification scores and detection accuracy after it is exposed even to simple attacks. We further study potential defense mechanisms against classifier evasion. Our experiments reveal that the original technique proposed for PDFrate is only effective if the executed attack exactly matches the anticipated one. In the discussion of the findings of our study, we analyze some potential techniques for increasing robustness of learning-based systems against adversarial manipulation of data.</p>
<p>【Keywords】:
 learning (artificial intelligence); pattern classification; security of data; PDFrate; adversarial data manipulation; learning-based classifier evasion; learning-based systems; malicious data detection; Feature extraction; Learning systems; Malware; Portable document format; Taxonomy; Training</p>
<h3 id="14. Doppelgänger Finder: Taking Stylometry to the Underground.">14. Doppelgänger Finder: Taking Stylometry to the Underground.</h3>
<p>【<a href="http://dx.doi.org/10.1109/SP.2014.21">Paper Link</a>】    【Pages】:212-226</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/a/Afroz:Sadia">Sadia Afroz</a> ; <a href="http://dblp.uni-trier.de/pers/hd/i/Islam:Aylin_Caliskan">Aylin Caliskan Islam</a> ; <a href="http://dblp.uni-trier.de/pers/hd/s/Stolerman:Ariel">Ariel Stolerman</a> ; <a href="http://dblp.uni-trier.de/pers/hd/g/Greenstadt:Rachel">Rachel Greenstadt</a> ; <a href="http://dblp.uni-trier.de/pers/hd/m/McCoy:Damon">Damon McCoy</a></p>
<p>【Abstract】:
Stylometry is a method for identifying anonymous authors of anonymous texts by analyzing their writing style. While stylometric methods have produced impressive results in previous experiments, we wanted to explore their performance on a challenging dataset of particular interest to the security research community. Analysis of underground forums can provide key information about who controls a given bot network or sells a service, and the size and scope of the cybercrime underworld. Previous analyses have been accomplished primarily through analysis of limited structured metadata and painstaking manual analysis. However, the key challenge is to automate this process, since this labor intensive manual approach clearly does not scale. We consider two scenarios. The first involves text written by an unknown cybercriminal and a set of potential suspects. This is standard, supervised stylometry problem made more difficult by multilingual forums that mix l33t-speak conversations with data dumps. In the second scenario, you want to feed a forum into an analysis engine and have it output possible doppelgangers, or users with multiple accounts. While other researchers have explored this problem, we propose a method that produces good results on actual separate accounts, as opposed to data sets created by artificially splitting authors into multiple identities. For scenario 1, we achieve 77% to 84% accuracy on private messages. For scenario 2, we achieve 94% recall with 90% precision on blogs and 85.18% precision with 82.14% recall for underground forum users. We demonstrate the utility of our approach with a case study that includes applying our technique to the Carders forum and manual analysis to validate the results, enabling the discovery of previously undetected doppelganger accounts.</p>
<p>【Keywords】:
 Internet; computer crime; meta data; standards; Carders forum; Doppelganger Finder; anonymous author identification; anonymous texts; cybercrime underworld; cybercriminal; data dumps; l33t-speak conversations; multilingual forums; security research community; structured metadata; stylometric methods; supervised stylometry problem; underground forum analysis; writing style analysis; Accuracy; Blogs; Detectors; Electronic mail; Manuals; Social network services; Stylometry; cybercrime; underground forum</p>
<h3 id="15. Hacking Blind.">15. Hacking Blind.</h3>
<p>【<a href="http://dx.doi.org/10.1109/SP.2014.22">Paper Link</a>】    【Pages】:227-242</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/b/Bittau:Andrea">Andrea Bittau</a> ; <a href="http://dblp.uni-trier.de/pers/hd/b/Belay:Adam">Adam Belay</a> ; <a href="http://dblp.uni-trier.de/pers/hd/m/Mashtizadeh:Ali_Jos=eacute=">Ali José Mashtizadeh</a> ; <a href="http://dblp.uni-trier.de/pers/hd/m/Mazi=egrave=res:David">David Mazières</a> ; <a href="http://dblp.uni-trier.de/pers/hd/b/Boneh:Dan">Dan Boneh</a></p>
<p>【Abstract】:
We show that it is possible to write remote stack buffer overflow exploits without possessing a copy of the target binary or source code, against services that restart after a crash. This makes it possible to hack proprietary closed-binary services, or open-source servers manually compiled and installed from source where the binary remains unknown to the attacker. Traditional techniques are usually paired against a particular binary and distribution where the hacker knows the location of useful gadgets for Return Oriented Programming (ROP). Our Blind ROP (BROP) attack instead remotely finds enough ROP gadgets to perform a write system call and transfers the vulnerable binary over the network, after which an exploit can be completed using known techniques. This is accomplished by leaking a single bit of information based on whether a process crashed or not when given a particular input string. BROP requires a stack vulnerability and a service that restarts after a crash. We implemented Braille, a fully automated exploit that yielded a shell in under 4,000 requests (20 minutes) against a contemporary nginx vulnerability, yaSSL + MySQL, and a toy proprietary server written by a colleague. The attack works against modern 64-bit Linux with address space layout randomization (ASLR), no-execute page protection (NX) and stack canaries.</p>
<p>【Keywords】:
 Linux; security of data; Braille; Linux; address space layout randomization; blind ROP attack; nginx vulnerability; no-execute page protection; open-source servers hacking; proprietary closed-binary services hacking; return oriented programming; stack buffer overflow; stack canaries; write system call; Computer crashes; Layout; Libraries; Linux; Registers; Servers; Sockets</p>
<h3 id="16. Framing Signals - A Return to Portable Shellcode.">16. Framing Signals - A Return to Portable Shellcode.</h3>
<p>【<a href="http://dx.doi.org/10.1109/SP.2014.23">Paper Link</a>】    【Pages】:243-258</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/b/Bosman:Erik">Erik Bosman</a> ; <a href="http://dblp.uni-trier.de/pers/hd/b/Bos:Herbert">Herbert Bos</a></p>
<p>【Abstract】:
Signal handling has been an integral part of UNIX systems since the earliest implementation in the 1970s. Nowadays, we find signals in all common flavors of UNIX systems, including BSD, Linux, Solaris, Android, and Mac OS. While each flavor handles signals in slightly different ways, the implementations are very similar. In this paper, we show that signal handling can be used as an attack method in exploits and backdoors. The problem has been a part of UNIX from the beginning, and now that advanced security measures like ASLR, DEP and stack cookies have made simple exploitation much harder, our technique is among the lowest hanging fruit available to an attacker. Specifically, we describe Sigreturn Oriented Programming (SROP), a novel technique for exploits and backdoors in UNIX-like systems. Like return-oriented programming (ROP), sigreturn oriented programming constructs what is known as a 'weird machine' that can be programmed by attackers to change the behavior of a process. To program the machine, attackers set up fake signal frames and initiate returns from signals that the kernel never really delivered. This is possible, because UNIX stores signal frames on the process' stack. Sigreturn oriented programming is interesting for attackers, OS developers and academics. For attackers, the technique is very versatile, with pre-conditions that are different from those of existing exploitation techniques like ROP. Moreover, unlike ROP, sigreturn oriented programming programs are portable. For OS developers, the technique presents a problem that has been present in one of the two main operating system families from its inception, while the fixes (which we also present) are non-trivial. From a more academic viewpoint, it is also interesting because we show that sigreturn oriented programming is Turing complete. We demonstrate the usefulness of the technique in three applications. First, we describe the exploitation of a vulnerable web server on different Linux dist- ibutions. Second, we build a very stealthy proof-of-concept backdoor. Third, we use SROP to bypass Apple's code signing and security vetting process by building an app that can execute arbitrary system calls. Finally, we discuss mitigation techniques.</p>
<p>【Keywords】:
 Linux; computer crime; ASLR; Android; Apples code signing; BSD; DEP; Linux distributions; Mac OS; OS developers; SROP; Solaris; Turing complete; UNIX systems; advanced security measures; attack method; attackers; exploitation techniques; fake signal frames; mitigation techniques; portable shellcode; process behavior; proof-of-concept backdoor; security vetting process; signal handling; sigreturn oriented programming; stack cookies; vulnerable Web server; weird machine; Context; Kernel; Linux; Program processors; Programming; Registers; Security; Operatings system security; backdoors; exploits</p>
<h2 id="Session 5: Systems Security    4">Session 5: Systems Security    4</h2>
<h3 id="17. Pivot: Fast, Synchronous Mashup Isolation Using Generator Chains.">17. Pivot: Fast, Synchronous Mashup Isolation Using Generator Chains.</h3>
<p>【<a href="http://dx.doi.org/10.1109/SP.2014.24">Paper Link</a>】    【Pages】:261-275</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/m/Mickens:James">James Mickens</a></p>
<p>【Abstract】:
Pivot is a new JavaScript isolation framework for web applications. Pivot uses iframes as its low-level isolation containers, but it uses code rewriting to implement synchronous cross-domain interfaces atop the asynchronous cross-frame postMessage( ) primitive. Pivot layers a distributed scheduling abstraction across the frames, essentially treating each frame as a thread which can invoke RPCs that are serviced by external threads. By rewriting JavaScript call sites, Pivot can detect RPC invocations, Pivot exchanges RPC requests and responses via postMessage( ), and it pauses and restarts frames using a novel rewriting technique that translates each frame's JavaScript code into a restart able generator function. By leveraging both iframes and rewriting, Pivot does not need to rewrite all code, providing an order-of-magnitude performance improvement over rewriting-only solutions. Compared to iframe-only approaches, Pivot provides synchronous RPC semantics, which developers typically prefer over asynchronous RPCs. Pivot also allows developers to use the full, unrestricted JavaScript language, including powerful statements like eval( ).</p>
<p>【Keywords】:
 Java; Web sites; program compilers; rewriting systems; JavaScript call sites; JavaScript code; JavaScript isolation framework; Pivot; RPC invocations; RPC requests; Web applications; asynchronous cross-frame postMessage() primitive; code rewriting; distributed scheduling abstraction; eval(); generator chains; iframe-only approaches; iframes; low-level isolation containers; order-of-magnitude performance improvement; restartable generator function; rewriting technique; rewriting-only solutions; synchronous cross-domain interfaces; synchronous mashup isolation; unrestricted JavaScript language; Browsers; Generators; Libraries; Reactive power; Runtime; Satellites; Security</p>
<h3 id="18. SoK: Automated Software Diversity.">18. SoK: Automated Software Diversity.</h3>
<p>【<a href="http://dx.doi.org/10.1109/SP.2014.25">Paper Link</a>】    【Pages】:276-291</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/l/Larsen:Per">Per Larsen</a> ; <a href="http://dblp.uni-trier.de/pers/hd/h/Homescu:Andrei">Andrei Homescu</a> ; <a href="http://dblp.uni-trier.de/pers/hd/b/Brunthaler:Stefan">Stefan Brunthaler</a> ; <a href="http://dblp.uni-trier.de/pers/hd/f/Franz:Michael">Michael Franz</a></p>
<p>【Abstract】:
The idea of automatic software diversity is at least two decades old. The deficiencies of currently deployed defenses and the transition to online software distribution (the "App store" model) for traditional and mobile computers has revived the interest in automatic software diversity. Consequently, the literature on diversity grew by more than two dozen papers since 2008. Diversity offers several unique properties. Unlike other defenses, it introduces uncertainty in the target. Precise knowledge of the target software provides the underpinning for a wide range of attacks. This makes diversity a broad rather than narrowly focused defense mechanism. Second, diversity offers probabilistic protection similar to cryptography-attacks may succeed by chance so implementations must offer high entropy. Finally, the design space of diversifying program transformations is large. As a result, researchers have proposed multiple approaches to software diversity that vary with respect to threat models, security, performance, and practicality. In this paper, we systematically study the state-of-the-art in software diversity and highlight fundamental trade-offs between fully automated approaches. We also point to open areas and unresolved challenges. These include "hybrid solutions", error reporting, patching, and implementation disclosure attacks on diversified software.</p>
<p>【Keywords】:
 cryptography; mobile computing; probability; software performance evaluation; App store model; SoK; automated software diversity; cryptography; error reporting; implementation disclosure attacks; mobile computers; online software distribution; patching attacks; probabilistic protection; program transformations; software attacks; Encoding; Layout; Monitoring; Operating systems; Registers; Security</p>
<h3 id="19. KCoFI: Complete Control-Flow Integrity for Commodity Operating System Kernels.">19. KCoFI: Complete Control-Flow Integrity for Commodity Operating System Kernels.</h3>
<p>【<a href="http://dx.doi.org/10.1109/SP.2014.26">Paper Link</a>】    【Pages】:292-307</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/c/Criswell:John">John Criswell</a> ; <a href="http://dblp.uni-trier.de/pers/hd/d/Dautenhahn:Nathan">Nathan Dautenhahn</a> ; <a href="http://dblp.uni-trier.de/pers/hd/a/Adve:Vikram_S=">Vikram S. Adve</a></p>
<p>【Abstract】:
We present a new system, KCoFI, that is the first we know of to provide complete Control-Flow Integrity protection for commodity operating systems without using heavyweight complete memory safety. Unlike previous systems, KCoFI protects commodity operating systems from classical control-flow hijack attacks, return-to-user attacks, and code segment modification attacks. We formally verify a subset of KCoFI's design by modeling several features in small-step semantics and providing a partial proof that the semantics maintain control-flow integrity. The model and proof account for operations such as page table management, trap handlers, context switching, and signal delivery. Our evaluation shows that KCoFI prevents all the gadgets found by an open-source Return Oriented Programming (ROP) gadget-finding tool in the FreeBSD kernel from being used, it also reduces the number of indirect control-flow targets by 98.18%. Our evaluation also shows that the performance impact of KCoFI on web server bandwidth is negligible while file transfer bandwidth using OpenSSH is reduced by an average of 13%, and at worst 27%, across a wide range of file sizes. Postmark, an extremely file-system intensive benchmark, shows 2x overhead. Where comparable numbers are available, the overheads of KCoFI are far lower than heavyweight memory-safety techniques.</p>
<p>【Keywords】:
 Internet; file servers; object-oriented programming; operating system kernels; public domain software; FreeBSD kernel; KCoFI; OpenSSH; PostMark; Web server bandwidth; code segment modification attacks; commodity operating system kernels; control-flow hijack attacks; control-flow integrity; file transfer bandwidth; file-system intensive benchmark; formal verification; heavyweight memory-safety techniques; indirect control-flow targets; open-source ROP gadget-finding tool; open-source return oriented programming gadget-finding tool; page table management; return-to-user attacks; signal delivery; small-step semantics; trap handlers; Context; Hardware; Instruction sets; Instruments; Kernel; Security; Free BSD; compiler; control-flow integrity; formal verification; operating systems</p>
<h3 id="20. Dancing with Giants: Wimpy Kernels for On-Demand Isolated I/O.">20. Dancing with Giants: Wimpy Kernels for On-Demand Isolated I/O.</h3>
<p>【<a href="http://dx.doi.org/10.1109/SP.2014.27">Paper Link</a>】    【Pages】:308-323</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/z/Zhou:Zongwei">Zongwei Zhou</a> ; <a href="http://dblp.uni-trier.de/pers/hd/y/Yu:Miao">Miao Yu</a> ; <a href="http://dblp.uni-trier.de/pers/hd/g/Gligor:Virgil_D=">Virgil D. Gligor</a></p>
<p>【Abstract】:
To be trustworthy, security-sensitive applications must be formally verified and hence small and simple, i.e., wimpy. Thus, they cannot include a variety of basic services available only in large and untrustworthy commodity systems, i.e., in giants. Hence, wimps must securely compose with giants to survive on commodity systems, i.e., rely on giants' services but only after efficiently verifying their results. This paper presents a security architecture based on a wimpy kernel that provides on-demand isolated I/O channels for wimp applications, without bloating the underlying trusted computing base. The size and complexity of the wimpy kernel are minimized by safely outsourcing I/O subsystem functions to an untrusted commodity operating system and exporting driver and I/O subsystem code to wimp applications. Using the USB subsystem as a case study, this paper illustrates the dramatic reduction of wimpy-kernel size and complexity, e.g., over 99% of the USB code base is removed. Performance measurements indicate that the wimpy-kernel architecture exhibits the desired execution efficiency.</p>
<p>【Keywords】:
 formal verification; operating systems (computers); peripheral interfaces; software architecture; trusted computing; I/O subsystem functions; USB code base; USB subsystem; commodity systems; formal verification; giants services; on-demand isolated I/O channels; security architecture; security-sensitive applications; trusted computing; trustworthy; untrusted commodity operating system; wimp applications; wimpy kernel complexity; wimpy kernel size; wimpy-kernel architecture; Complexity theory; Hardware; Kernel; Linux; Security; Universal Serial Bus</p>
<h2 id="Session 6: Privacy and Anonymity    4">Session 6: Privacy and Anonymity    4</h2>
<h3 id="21. Bootstrapping Privacy Compliance in Big Data Systems.">21. Bootstrapping Privacy Compliance in Big Data Systems.</h3>
<p>【<a href="http://dx.doi.org/10.1109/SP.2014.28">Paper Link</a>】    【Pages】:327-342</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/s/Sen:Shayak">Shayak Sen</a> ; <a href="http://dblp.uni-trier.de/pers/hd/g/Guha:Saikat">Saikat Guha</a> ; <a href="http://dblp.uni-trier.de/pers/hd/d/Datta:Anupam">Anupam Datta</a> ; <a href="http://dblp.uni-trier.de/pers/hd/r/Rajamani:Sriram_K=">Sriram K. Rajamani</a> ; <a href="http://dblp.uni-trier.de/pers/hd/t/Tsai:Janice_Y=">Janice Y. Tsai</a> ; <a href="http://dblp.uni-trier.de/pers/hd/w/Wing:Jeannette_M=">Jeannette M. Wing</a></p>
<p>【Abstract】:
With the rapid increase in cloud services collecting and using user data to offer personalized experiences, ensuring that these services comply with their privacy policies has become a business imperative for building user trust. However, most compliance efforts in industry today rely on manual review processes and audits designed to safeguard user data, and therefore are resource intensive and lack coverage. In this paper, we present our experience building and operating a system to automate privacy policy compliance checking in Bing. Central to the design of the system are (a) Legal ease-a language that allows specification of privacy policies that impose restrictions on how user data is handled, and (b) Grok-a data inventory for Map-Reduce-like big data systems that tracks how user data flows among programs. Grok maps code-level schema elements to data types in Legal ease, in essence, annotating existing programs with information flow types with minimal human input. Compliance checking is thus reduced to information flow analysis of Big Data systems. The system, bootstrapped by a small team, checks compliance daily of millions of lines of ever-changing source code written by several thousand developers.</p>
<p>【Keywords】:
 Big Data; Web services; cloud computing; computer bootstrapping; conformance testing; data privacy; parallel programming; search engines; source code (software); Bing; Grok data inventory; Legal ease language; Map-Reduce-like Big Data systems; automatic privacy policy compliance checking; business imperative privacy policies; cloud services; code-level schema element mapping; datatypes; information flow types; minimal human input; personalized user experiences; privacy compliance bootstrapping; privacy policy specification; program annotation; source code; user data handling; user trust; Advertising; Big data; Data privacy; IP networks; Lattices; Privacy; Semantics; big data; bing; compliance; information flow; policy; privacy; program analysis</p>
<h3 id="22. Formal Analysis of Chaumian Mix Nets with Randomized Partial Checking.">22. Formal Analysis of Chaumian Mix Nets with Randomized Partial Checking.</h3>
<p>【<a href="http://dx.doi.org/10.1109/SP.2014.29">Paper Link</a>】    【Pages】:343-358</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/k/K=uuml=sters:Ralf">Ralf Küsters</a> ; <a href="http://dblp.uni-trier.de/pers/hd/t/Truderung:Tomasz">Tomasz Truderung</a> ; <a href="http://dblp.uni-trier.de/pers/hd/v/Vogt_0001:Andreas">Andreas Vogt</a></p>
<p>【Abstract】:
Mix nets with randomized partial checking (RPC mix nets) have been introduced by Jakobsson, Juels, and Rivest as particularly simple and efficient verifiable mix nets. These mix nets have been used in several implementations of prominent e-voting systems to provide vote privacy and verifiability. In RPC mix nets, higher efficiency is traded for a lower level of privacy and verifiability. However, these mix nets have never undergone a rigorous formal analysis. Recently, Kahazei and Wikstroem even pointed out several severe problems in the original proposal and in implementations of RPC mix nets in e-voting systems, both for so-called re-encryption and Chaumian RPC mix nets. While Kahazei and Wikstroem proposed several fixes, the security status of Chaumian RPC mix nets (with the fixes applied) has been left open, re-encryption RPC mix nets, as they suggest, should not be used at all. In this paper, we provide the first formal security analysis of Chaumian RPC mix nets. We propose security definitions that allow one to measure the level of privacy and verifiability RPC mix nets offer, and then based on these definitions, carry out a rigorous analysis. Altogether, our results show that these mix nets provide a reasonable level of privacy and verifiability, and that they are still an interesting option for the use in e-voting systems.</p>
<p>【Keywords】:
 cryptography; data privacy; government data processing; politics; Chaumian RPC mix nets; e-voting systems; formal security analysis; randomized partial checking; reencryption RPC mix nets; vote privacy; vote verifiability; Electronic voting; Privacy; Protocols; Public key; Servers; Accountability; Cryptographic Analysis; Mix Nets; Privacy; Random Partial Checking; Verifiability</p>
<h3 id="23. Blind Seer: A Scalable Private DBMS.">23. Blind Seer: A Scalable Private DBMS.</h3>
<p>【<a href="http://dx.doi.org/10.1109/SP.2014.30">Paper Link</a>】    【Pages】:359-374</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/p/Pappas:Vasilis">Vasilis Pappas</a> ; <a href="http://dblp.uni-trier.de/pers/hd/k/Krell:Fernando">Fernando Krell</a> ; <a href="http://dblp.uni-trier.de/pers/hd/v/Vo:Binh">Binh Vo</a> ; <a href="http://dblp.uni-trier.de/pers/hd/k/Kolesnikov:Vladimir">Vladimir Kolesnikov</a> ; <a href="http://dblp.uni-trier.de/pers/hd/m/Malkin:Tal">Tal Malkin</a> ; <a href="http://dblp.uni-trier.de/pers/hd/c/Choi:Seung_Geol">Seung Geol Choi</a> ; <a href="http://dblp.uni-trier.de/pers/hd/g/George:Wesley">Wesley George</a> ; <a href="http://dblp.uni-trier.de/pers/hd/k/Keromytis:Angelos_D=">Angelos D. Keromytis</a> ; <a href="http://dblp.uni-trier.de/pers/hd/b/Bellovin:Steve">Steve Bellovin</a></p>
<p>【Abstract】:
Query privacy in secure DBMS is an important feature, although rarely formally considered outside the theoretical community. Because of the high overheads of guaranteeing privacy in complex queries, almost all previous works addressing practical applications consider limited queries (e.g., just keyword search), or provide a weak guarantee of privacy. In this work, we address a major open problem in private DB: efficient sub linear search for arbitrary Boolean queries. We consider scalable DBMS with provable security for all parties, including protection of the data from both server (who stores encrypted data) and client (who searches it), as well as protection of the query, and access control for the query. We design, build, and evaluate the performance of a rich DBMS system, suitable for real-world deployment on today medium-to large-scale DBs. On a modern server, we are able to query a formula over 10TB, 100M-record DB, with 70 searchable index terms per DB row, in time comparable to (insecure) MySQL (many practical queries can be privately executed with work 1.2-3 times slower than MySQL, although some queries are costlier). We support a rich query set, including searching on arbitrary boolean formulas on keywords and ranges, support for stemming, and free keyword searches over text fields. We identify and permit a reasonable and controlled amount of leakage, proving that no further leakage is possible. In particular, we allow leakage of some search pattern information, but protect the query and data, provide a high level of privacy for individual terms in the executed search formula, and hide the difference between a query that returned no results and a query that returned a very small result set. We also support private and complex access policies, integrated in the search process so that a query with empty result set and a query that fails the policy are hard to tell apart.</p>
<p>【Keywords】:
 data privacy; database management systems; query processing; Blind Seer; MySQL; arbitrary Boolean queries; data protection; encrypted data; free keyword searches; medium-to large-scale DB; query control; query privacy; scalable private DBMS; search pattern information; secure DBMS; stemming support; sublinear search; text fields; Cryptography; Data privacy; Indexes; Privacy; Servers; Private database; private search</p>
<h3 id="24. ANONIZE: A Large-Scale Anonymous Survey System.">24. ANONIZE: A Large-Scale Anonymous Survey System.</h3>
<p>【<a href="http://dx.doi.org/10.1109/SP.2014.31">Paper Link</a>】    【Pages】:375-389</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/h/Hohenberger:Susan">Susan Hohenberger</a> ; <a href="http://dblp.uni-trier.de/pers/hd/m/Myers:Steven">Steven Myers</a> ; <a href="http://dblp.uni-trier.de/pers/hd/p/Pass:Rafael">Rafael Pass</a> ; <a href="http://dblp.uni-trier.de/pers/hd/s/Shelat:Abhi">Abhi Shelat</a></p>
<p>【Abstract】:
A secure ad-hoc survey scheme enables a survey authority to independently (without any interaction) select an ad-hoc group of registered users based only on their identities (e.g., their email addresses), and create a survey where only selected users can anonymously submit exactly one response. We present a formalization of secure ad-hoc surveys and a provably-secure implementation in the random oracle model, called ANONIZE. Our performance analysis shows that ANONIZE enables securely implementing million-person anonymous surveys using a single modern workstation. As far as we know, ANONIZE constitutes the first implementation of a large-scale secure computation protocol (of non-trivial functionalities) that scales to millions of users.</p>
<p>【Keywords】:
 authorisation; cryptographic protocols; ANONIZE; ad-hoc group; email addresses; large-scale anonymous survey system; large-scale secure computation protocol; modern workstation; nontrivial functionalities; person anonymous surveys; provably-secure implementation; random oracle model; secure ad-hoc survey scheme; survey authority; user identities; Abstracts; Educational institutions; Electronic mail; Protocols; Public key; Registers; ANONIZE; secure anonymous survey system</p>
<h2 id="Session 7: Android    3">Session 7: Android    3</h2>
<h3 id="25. Upgrading Your Android, Elevating My Malware: Privilege Escalation through Mobile OS Updating.">25. Upgrading Your Android, Elevating My Malware: Privilege Escalation through Mobile OS Updating.</h3>
<p>【<a href="http://dx.doi.org/10.1109/SP.2014.32">Paper Link</a>】    【Pages】:393-408</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/x/Xing:Luyi">Luyi Xing</a> ; <a href="http://dblp.uni-trier.de/pers/hd/p/Pan:Xiaorui">Xiaorui Pan</a> ; <a href="http://dblp.uni-trier.de/pers/hd/w/Wang_0010:Rui">Rui Wang</a> ; <a href="http://dblp.uni-trier.de/pers/hd/y/Yuan:Kan">Kan Yuan</a> ; <a href="http://dblp.uni-trier.de/pers/hd/w/Wang:XiaoFeng">XiaoFeng Wang</a></p>
<p>【Abstract】:
Android is a fast evolving system, with new updates coming out one after another. These updates often completely overhaul a running system, replacing and adding tens of thousands of files across Android's complex architecture, in the presence of critical user data and applications (apps for short). To avoid accidental damages to such data and existing apps, the upgrade process involves complicated program logic, whose security implications, however, are less known. In this paper, we report the first systematic study on the Android updating mechanism, focusing on its Package Management Service (PMS). Our research brought to light a new type of security-critical vulnerabilities, called Pileup flaws, through which a malicious app can strategically declare a set of privileges and attributes on a low-version operating system (OS) and wait until it is upgraded to escalate its privileges on the new system. Specifically, we found that by exploiting the Pileup vulnerabilities, the app can not only acquire a set of newly added system and signature permissions but also determine their settings (e.g., protection levels), and it can further substitute for new system apps, contaminate their data (e.g., cache, cookies of Android default browser) to steal sensitive user information or change security configurations, and prevent installation of critical system services. We systematically analyzed the source code of PMS using a program verification tool and confirmed the presence of those security flaws on all Android official versions and over 3000 customized versions. Our research also identified hundreds of exploit opportunities the adversary can leverage over thousands of devices across different device manufacturers, carriers and countries. To mitigate this threat without endangering user data and apps during an upgrade, we also developed a new detection service, called SecUP, which deploys a scanner on the user's device to capture the malicious apps designed to exploit Pileu- vulnerabilities, based upon the vulnerability-related information automatically collected from newly released Android OS images.</p>
<p>【Keywords】:
 Android (operating system); formal verification; invasive software; mobile computing; Android OS images; PMS; Pileup flaws; low-version operating system; malicious apps; malware; mobile OS updating; operating systems; package management service; program verification tool; security configuration; security-critical vulnerability; user information; Androids; Google; Humanoid robots; Mobile communication; Registers; Security; Smart phones; Android; OS update; Package Manager Service; Privilege Escalation</p>
<h3 id="26. The Peril of Fragmentation: Security Hazards in Android Device Driver Customizations.">26. The Peril of Fragmentation: Security Hazards in Android Device Driver Customizations.</h3>
<p>【<a href="http://dx.doi.org/10.1109/SP.2014.33">Paper Link</a>】    【Pages】:409-423</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/z/Zhou:Xiao=yong">Xiao-yong Zhou</a> ; <a href="http://dblp.uni-trier.de/pers/hd/l/Lee:Yeonjoon">Yeonjoon Lee</a> ; <a href="http://dblp.uni-trier.de/pers/hd/z/Zhang:Nan">Nan Zhang</a> ; <a href="http://dblp.uni-trier.de/pers/hd/n/Naveed_0001:Muhammad">Muhammad Naveed</a> ; <a href="http://dblp.uni-trier.de/pers/hd/w/Wang:XiaoFeng">XiaoFeng Wang</a></p>
<p>【Abstract】:
Android phone manufacturers are under the perpetual pressure to move quickly on their new models, continuously customizing Android to fit their hardware. However, the security implications of this practice are less known, particularly when it comes to the changes made to Android's Linux device drivers, e.g., those for camera, GPS, NFC etc. In this paper, we report the first study aimed at a better understanding of the security risks in this customization process. Our study is based on ADDICTED, a new tool we built for automatically detecting some types of flaws in customized driver protection. Specifically, on a customized phone, ADDICTED performs dynamic analysis to correlate the operations on a security-sensitive device to its related Linux files, and then determines whether those files are under-protected on the Linux layer by comparing them with their counterparts on an official Android OS. In this way, we can detect a set of likely security flaws on the phone. Using the tool, we analyzed three popular phones from Samsung, identified their likely flaws and built end-to-end attacks that allow an unprivileged app to take pictures and screenshots, and even log the keys the user enters through touch screen. Some of those flaws are found to exist on over a hundred phone models and affect millions of users. We reported the flaws and helped the manufacturers fix those problems. We further studied the security settings of device files on 2423 factory images from major phone manufacturers, discovered over 1,000 vulnerable images and also gained insights about how they are distributed across different Android versions, carriers and countries.</p>
<p>【Keywords】:
 Android (operating system); computer crime; device drivers; flaw detection; smart phones; ADDICTED tool; Android Linux device driver customizations; Android OS; Android phone manufacturers; Linux files; Linux layer; Samsung phones; customized driver protection; customized phone; device files; dynamic analysis; end-to-end attacks; flaws detection; phone models; security flaws; security hazards; security implications; security risks; security settings; security-sensitive device; Cameras; Hardware; Kernel; Linux; Performance evaluation; Security; Smart phones; Android Security; Privacy</p>
<h3 id="27. From Zygote to Morula: Fortifying Weakened ASLR on Android.">27. From Zygote to Morula: Fortifying Weakened ASLR on Android.</h3>
<p>【<a href="http://dx.doi.org/10.1109/SP.2014.34">Paper Link</a>】    【Pages】:424-439</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/l/Lee:Byoungyoung">Byoungyoung Lee</a> ; <a href="http://dblp.uni-trier.de/pers/hd/l/Lu:Long">Long Lu</a> ; <a href="http://dblp.uni-trier.de/pers/hd/w/Wang:Tielei">Tielei Wang</a> ; <a href="http://dblp.uni-trier.de/pers/hd/k/Kim:Taesoo">Taesoo Kim</a> ; <a href="http://dblp.uni-trier.de/pers/hd/l/Lee:Wenke">Wenke Lee</a></p>
<p>【Abstract】:
There have been many research efforts to secure Android applications and the high-level system mechanisms. The low-level operating system designs have been overlooked partially due to the belief that security issues at this level are similar to those on Linux, which are well-studied. However, we identify that certain Android modifications are at odds with security and result in serious vulnerabilities that need to be addressed immediately. In this paper, we analyze the Zygote process creation model, an Android operating system design for speeding up application launches. Zygote weakens Address Space Layout Randomization (ASLR) because all application processes are created with largely identical memory layouts. We design both remote and local attacks capable of bypassing the weakened ASLR and executing return-oriented programming on Android. We demonstrate the attacks using real applications, such as the Chrome Browser and VLC Media Player. Further, we design and implement Morula, a secure replacement for Zygote. Morula introduces a small amount of code to the Android operating system and can be easily adopted by device vendors. Our evaluation shows that, compared to Zygote, Morula incurs a 13 MB memory increase for each running application but allows each Android process to have an individually randomized memory layout and even a slightly shorter average launch time.</p>
<p>【Keywords】:
 Android (operating system); security of data; Android modifications; Android operating system design; Chrome browser; Morula; VLC media player; Zygote process creation model; address space layout randomization; individually randomized memory layout; low-level operating system designs; return-oriented programming; security issues; weakened ASLR fortification; Androids; Browsers; Humanoid robots; Layout; Libraries; Media; Security; ASLR; Android; Security</p>
<h2 id="Session 8: E-Cash    3">Session 8: E-Cash    3</h2>
<h3 id="28. Secure Multiparty Computations on Bitcoin.">28. Secure Multiparty Computations on Bitcoin.</h3>
<p>【<a href="http://dx.doi.org/10.1109/SP.2014.35">Paper Link</a>】    【Pages】:443-458</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/a/Andrychowicz:Marcin">Marcin Andrychowicz</a> ; <a href="http://dblp.uni-trier.de/pers/hd/d/Dziembowski:Stefan">Stefan Dziembowski</a> ; <a href="http://dblp.uni-trier.de/pers/hd/m/Malinowski:Daniel">Daniel Malinowski</a> ; <a href="http://dblp.uni-trier.de/pers/hd/m/Mazurek:Lukasz">Lukasz Mazurek</a></p>
<p>【Abstract】:
Bit coin is a decentralized digital currency, introduced in 2008, that has recently gained noticeable popularity. Its main features are: (a) it lacks a central authority that controls the transactions, (b) the list of transactions is publicly available, and (c) its syntax allows more advanced transactions than simply transferring the money. The goal of this paper is to show how these properties of Bit coin can be used in the area of secure multiparty computation protocols (MPCs). Firstly, we show that the Bit coin system provides an attractive way to construct a version of "timed commitments", where the committer has to reveal his secret within a certain time frame, or to pay a fine. This, in turn, can be used to obtain fairness in some multiparty protocols. Secondly, we introduce a concept of multiparty protocols that work "directly on Bit coin". Recall that the standard definition of the MPCs guarantees only that the protocol "emulates the trusted third party". Hence ensuring that the inputs are correct, and the outcome is respected is beyond the scope of the definition. Our observation is that the Bit coin system can be used to go beyond the standard "emulation-based" definition, by constructing protocols that link their inputs and the outputs with the real Bit coin transactions. As an instantiation of this idea we construct protocols for secure multiparty lotteries using the Bit coin currency, without relying on a trusted authority (one of these protocols uses the Bit coin-based timed commitments mentioned above). Our protocols guarantee fairness for the honest parties no matter how the loser behaves. For example: if one party interrupts the protocol then her money is transferred to the honest participants. Our protocols are practical (to demonstrate it we performed their transactions in the actual Bit coin system), and can be used in real life as a replacement for the online gambling sites. We think that this paradigm can have also other applications. We discu- s some of them.</p>
<p>【Keywords】:
 cryptographic protocols; electronic money; Bitcoin; MPC; decentralized digital currency; emulation-based definition; online gambling sites; secure multiparty computation protocols; secure multiparty lotteries; timed commitments; Cryptography; Games; Internet; Online banking; Protocols; Standards; bitocoin; lottery; multiparty computations</p>
<h3 id="29. Zerocash: Decentralized Anonymous Payments from Bitcoin.">29. Zerocash: Decentralized Anonymous Payments from Bitcoin.</h3>
<p>【<a href="http://dx.doi.org/10.1109/SP.2014.36">Paper Link</a>】    【Pages】:459-474</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/b/Ben=Sasson:Eli">Eli Ben-Sasson</a> ; <a href="http://dblp.uni-trier.de/pers/hd/c/Chiesa:Alessandro">Alessandro Chiesa</a> ; <a href="http://dblp.uni-trier.de/pers/hd/g/Garman:Christina">Christina Garman</a> ; <a href="http://dblp.uni-trier.de/pers/hd/g/Green_0001:Matthew">Matthew Green</a> ; <a href="http://dblp.uni-trier.de/pers/hd/m/Miers:Ian">Ian Miers</a> ; <a href="http://dblp.uni-trier.de/pers/hd/t/Tromer:Eran">Eran Tromer</a> ; <a href="http://dblp.uni-trier.de/pers/hd/v/Virza:Madars">Madars Virza</a></p>
<p>【Abstract】:
Bit coin is the first digital currency to see widespread adoption. While payments are conducted between pseudonyms, Bit coin cannot offer strong privacy guarantees: payment transactions are recorded in a public decentralized ledger, from which much information can be deduced. Zero coin (Miers et al., IEEE S&amp;P 2013) tackles some of these privacy issues by unlinking transactions from the payment's origin. Yet, it still reveals payments' destinations and amounts, and is limited in functionality. In this paper, we construct a full-fledged ledger-based digital currency with strong privacy guarantees. Our results leverage recent advances in zero-knowledge Succinct Non-interactive Arguments of Knowledge (zk-SNARKs). First, we formulate and construct decentralized anonymous payment schemes (DAP schemes). A DAP scheme enables users to directly pay each other privately: the corresponding transaction hides the payment's origin, destination, and transferred amount. We provide formal definitions and proofs of the construction's security. Second, we build Zero cash, a practical instantiation of our DAP scheme construction. In Zero cash, transactions are less than 1 kB and take under 6 ms to verify - orders of magnitude more efficient than the less-anonymous Zero coin and competitive with plain Bit coin.</p>
<p>【Keywords】:
 data privacy; electronic money; Bitcoin; DAP schemes; Zero cash; Zerocash; decentralized anonymous payment schemes; decentralized anonymous payments; full-fledged ledger-based digital currency; payment transactions; privacy guarantees; public decentralized ledger; zero-knowledge succinct noninteractive arguments of knowledge; zk-SNARKs; Logic gates; Online banking; Privacy; Protocols; Public key; Bitcoin; decentralized electronic cash; zero knowledge</p>
<h3 id="30. Permacoin: Repurposing Bitcoin Work for Data Preservation.">30. Permacoin: Repurposing Bitcoin Work for Data Preservation.</h3>
<p>【<a href="http://dx.doi.org/10.1109/SP.2014.37">Paper Link</a>】    【Pages】:475-490</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/m/Miller:Andrew">Andrew Miller</a> ; <a href="http://dblp.uni-trier.de/pers/hd/j/Juels:Ari">Ari Juels</a> ; <a href="http://dblp.uni-trier.de/pers/hd/s/Shi:Elaine">Elaine Shi</a> ; <a href="http://dblp.uni-trier.de/pers/hd/p/Parno:Bryan">Bryan Parno</a> ; <a href="http://dblp.uni-trier.de/pers/hd/k/Katz:Jonathan">Jonathan Katz</a></p>
<p>【Abstract】:
Bit coin is widely regarded as the first broadly successful e-cash system. An oft-cited concern, though, is that mining Bit coins wastes computational resources. Indeed, Bit coin's underlying mining mechanism, which we call a scratch-off puzzle (SOP), involves continuously attempting to solve computational puzzles that have no intrinsic utility. We propose a modification to Bit coin that repurposes its mining resources to achieve a more broadly useful goal: distributed storage of archival data. We call our new scheme Perm coin. Unlike Bit coin and its proposed alternatives, Perm coin requires clients to invest not just computational resources, but also storage. Our scheme involves an alternative scratch-off puzzle for Bit coin based on Proofs-of-Retrievability (PORs). Successfully minting money with this SOP requires local, random access to a copy of a file. Given the competition among mining clients in Bit coin, this modified SOP gives rise to highly decentralized file storage, thus reducing the overall waste of Bit coin. Using a model of rational economic agents we show that our modified SOP preserves the essential properties of the original Bit coin puzzle. We also provide parameterizations and calculations based on realistic hardware constraints to demonstrate the practicality of Perm coin as a whole.</p>
<p>【Keywords】:
 data mining; digital storage; electronic money; Bit coin mining; Bitcoin; Perm coin; Permacoin; archival data; computational puzzles; computational resources; data preservation; distributed storage; e-cash system; proofs-of-retrievability; rational economic agents; scratch-off puzzle; Data mining; Investment; Online banking; Outsourcing; Peer-to-peer computing; Public key</p>
<h2 id="Session 8: Miscellaneous    4">Session 8: Miscellaneous    4</h2>
<h3 id="31. Cloak and Swagger: Understanding Data Sensitivity through the Lens of User Anonymity.">31. Cloak and Swagger: Understanding Data Sensitivity through the Lens of User Anonymity.</h3>
<p>【<a href="http://dx.doi.org/10.1109/SP.2014.38">Paper Link</a>】    【Pages】:493-508</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/p/Peddinti:Sai_Teja">Sai Teja Peddinti</a> ; <a href="http://dblp.uni-trier.de/pers/hd/k/Korolova:Aleksandra">Aleksandra Korolova</a> ; <a href="http://dblp.uni-trier.de/pers/hd/b/Bursztein:Elie">Elie Bursztein</a> ; <a href="http://dblp.uni-trier.de/pers/hd/s/Sampemane:Geetanjali">Geetanjali Sampemane</a></p>
<p>【Abstract】:
Most of what we understand about data sensitivity is through user self-report (e.g., surveys), this paper is the first to use behavioral data to determine content sensitivity, via the clues that users give as to what information they consider private or sensitive through their use of privacy enhancing product features. We perform a large-scale analysis of user anonymity choices during their activity on Quora, a popular question-and-answer site. We identify categories of questions for which users are more likely to exercise anonymity and explore several machine learning approaches towards predicting whether a particular answer will be written anonymously. Our findings validate the viability of the proposed approach towards an automatic assessment of data sensitivity, show that data sensitivity is a nuanced measure that should be viewed on a continuum rather than as a binary concept, and advance the idea that machine learning over behavioral data can be effectively used in order to develop product features that can help keep users safe.</p>
<p>【Keywords】:
 data privacy; learning (artificial intelligence); Quora; automatic assessment; behavioral data; cloak; content sensitivity; data sensitivity; machine learning; privacy enhancing product features; question-and-answer site; swagger; user anonymity; user self-report; Context; Crawlers; Data privacy; Facebook; Privacy; Search engines; Sensitivity</p>
<h3 id="32. Stopping a Rapid Tornado with a Puff.">32. Stopping a Rapid Tornado with a Puff.</h3>
<p>【<a href="http://dx.doi.org/10.1109/SP.2014.39">Paper Link</a>】    【Pages】:509-523</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/l/Lopes:Jose">Jose Lopes</a> ; <a href="http://dblp.uni-trier.de/pers/hd/n/Neves:Nuno">Nuno Neves</a></p>
<p>【Abstract】:
RaptorQ is the most advanced fountain code proposed so far. Its properties make it attractive for forward error correction (FEC), offering high reliability at low overheads (i.e., for a small amount of repair information) and efficient encoding and decoding operations. Since RaptorQ's emergence, it has already been standardized by the IETF, and there is the expectation that it will be adopted by several other standardization bodies, in areas related to digital media broadcast, cellular networks, and satellite communications. The paper describes a new attack on RaptorQ that breaks the near ideal FEC performance, by carefully choosing which packets are allowed to reach the receiver. Furthermore, the attack was extended to be performed over secure channels with IPsec/ESP. The paper also proposes a few solutions to protect the code from the attack, which could be easily integrated into the implementations.</p>
<p>【Keywords】:
 cryptography; data protection; decoding; encoding; forward error correction; telecommunication security; FEC; IETF; IPsec-ESP; RaptorQ; advanced fountain code; cellular networks; code protection; decoding operations; digital media broadcast; encoding operations; forward error correction; satellite communications; secure channels; Decoding; Encoding; Equations; Generators; Maintenance engineering; Mathematical model; Receivers; fountain codes; malicious faults; raptor codes; resilience</p>
<h3 id="33. SoK: Security and Privacy in Implantable Medical Devices and Body Area Networks.">33. SoK: Security and Privacy in Implantable Medical Devices and Body Area Networks.</h3>
<p>【<a href="http://dx.doi.org/10.1109/SP.2014.40">Paper Link</a>】    【Pages】:524-539</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/r/Rushanan:Michael">Michael Rushanan</a> ; <a href="http://dblp.uni-trier.de/pers/hd/r/Rubin:Aviel_D=">Aviel D. Rubin</a> ; <a href="http://dblp.uni-trier.de/pers/hd/k/Kune:Denis_Foo">Denis Foo Kune</a> ; <a href="http://dblp.uni-trier.de/pers/hd/s/Swanson:Colleen_M=">Colleen M. Swanson</a></p>
<p>【Abstract】:
Balancing security, privacy, safety, and utility is a necessity in the health care domain, in which implantable medical devices (IMDs) and body area networks (BANs) have made it possible to continuously and automatically manage and treat a number of health conditions. In this work, we survey publications aimed at improving security and privacy in IMDs and health-related BANs, providing clear definitions and a comprehensive overview of the problem space. We analyze common themes, categorize relevant results, and identify trends and directions for future research. We present a visual illustration of this analysis that shows the progression of IMD/BAN research and highlights emerging threats. We identify three broad research categories aimed at ensuring the security and privacy of the telemetry interface, software, and sensor interface layers and discuss challenges researchers face with respect to ensuring reproducibility of results. We find that while the security of the telemetry interface has received much attention in academia, the threat of software exploitation and the sensor interface layer deserve further attention. In addition, we observe that while the use of physiological values as a source of entropy for cryptographic keys holds some promise, a more rigorous assessment of the security and practicality of these schemes is required.</p>
<p>【Keywords】:
 biomedical equipment; biomedical telemetry; body area networks; data privacy; health care; private key cryptography; prosthetics; radiotelemetry; IMD; SoK; body area networks; cryptographic keys; entropy source; health care domain; health conditions; health-related BAN; implantable medical devices; physiological values; privacy improvement; safety issue; security improvement; sensor interface layers; software exploitation threat; telemetry interface; utility issue; Communication system security; Medical diagnostic imaging; Privacy; Security; Telemetry; Wireless communication; Wireless sensor networks; body area networks; health; implantable medical devices; privacy; security</p>
<h3 id="34. Quantifying Information Flow for Dynamic Secrets.">34. Quantifying Information Flow for Dynamic Secrets.</h3>
<p>【<a href="http://dx.doi.org/10.1109/SP.2014.41">Paper Link</a>】    【Pages】:540-555</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/m/Mardziel:Piotr">Piotr Mardziel</a> ; <a href="http://dblp.uni-trier.de/pers/hd/a/Alvim:M=aacute=rio_S=">Mário S. Alvim</a> ; <a href="http://dblp.uni-trier.de/pers/hd/h/Hicks:Michael_W=">Michael W. Hicks</a> ; <a href="http://dblp.uni-trier.de/pers/hd/c/Clarkson:Michael_R=">Michael R. Clarkson</a></p>
<p>【Abstract】:
A metric is proposed for quantifying leakage of information about secrets and about how secrets change over time. The metric is used with a model of information flow for probabilistic, interactive systems with adaptive adversaries. The model and metric are implemented in a probabilistic programming language and used to analyze several examples. The analysis demonstrates that adaptivity increases information flow.</p>
<p>【Keywords】:
 cryptography; high level languages; interactive systems; probability; dynamic secrets; information flow; information leakage; interactive systems; probabilistic programming language; probabilistic systems; Adaptation models; Automata; Context; History; Measurement; Probabilistic logic; Security; dynamic secret; gain function; probabilistic programming; quantitative information flow; vulnerability</p>
<h2 id="Session 9: Attacks 3    4">Session 9: Attacks 3    4</h2>
<h3 id="35. Not-So-Random Numbers in Virtualized Linux and the Whirlwind RNG.">35. Not-So-Random Numbers in Virtualized Linux and the Whirlwind RNG.</h3>
<p>【<a href="http://dx.doi.org/10.1109/SP.2014.42">Paper Link</a>】    【Pages】:559-574</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/e/Everspaugh:Adam">Adam Everspaugh</a> ; <a href="http://dblp.uni-trier.de/pers/hd/z/Zhai:Yan">Yan Zhai</a> ; <a href="http://dblp.uni-trier.de/pers/hd/j/Jellinek:Robert">Robert Jellinek</a> ; <a href="http://dblp.uni-trier.de/pers/hd/r/Ristenpart:Thomas">Thomas Ristenpart</a> ; <a href="http://dblp.uni-trier.de/pers/hd/s/Swift:Michael_M=">Michael M. Swift</a></p>
<p>【Abstract】:
Virtualized environments are widely thought to cause problems for software-based random number generators (RNGs), due to use of virtual machine (VM) snapshots as well as fewer and believed-to-be lower quality entropy sources. Despite this, we are unaware of any published analysis of the security of critical RNGs when running in VMs. We fill this gap, using measurements of Linux's RNG systems (without the aid of hardware RNGs, the most common use case today) on Xen, VMware, and Amazon EC2. Despite CPU cycle counters providing a significant source of entropy, various deficiencies in the design of the Linux RNG makes its first output vulnerable during VM boots and, more critically, makes it suffer from catastrophic reset vulnerabilities. We show cases in which the RNG will output the exact same sequence of bits each time it is resumed from the same snapshot. This can compromise, for example, cryptographic secrets generated after resumption. We explore legacy-compatible countermeasures, as well as a clean-slate solution. The latter is a new RNG called Whirlwind that provides a simpler, more-secure solution for providing system randomness.</p>
<p>【Keywords】:
 Linux; virtual machines; Linux RNG systems; VM boots; VM snapshots; Whirlwind RNG; cryptographic secrets; entropy sources; not-so-random numbers; software-based random number generators; virtual machine; virtualized Linux; virtualized environments; Cryptography; Entropy; Hardware; Instruments; Kernel; Linux; random number generator; virtualization</p>
<h3 id="36. Out of Control: Overcoming Control-Flow Integrity.">36. Out of Control: Overcoming Control-Flow Integrity.</h3>
<p>【<a href="http://dx.doi.org/10.1109/SP.2014.43">Paper Link</a>】    【Pages】:575-589</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/g/G=ouml=ktas:Enes">Enes Göktas</a> ; <a href="http://dblp.uni-trier.de/pers/hd/a/Athanasopoulos:Elias">Elias Athanasopoulos</a> ; <a href="http://dblp.uni-trier.de/pers/hd/b/Bos:Herbert">Herbert Bos</a> ; <a href="http://dblp.uni-trier.de/pers/hd/p/Portokalidis:Georgios">Georgios Portokalidis</a></p>
<p>【Abstract】:
As existing defenses like ASLR, DEP, and stack cookies are not sufficient to stop determined attackers from exploiting our software, interest in Control Flow Integrity (CFI) is growing. In its ideal form, CFI prevents flows of control that were not intended by the original program, effectively putting a stop to exploitation based on return oriented programming (and many other attacks besides). Two main problems have prevented CFI from being deployed in practice. First, many CFI implementations require source code or debug information that is typically not available for commercial software. Second, in its ideal form, the technique is very expensive. It is for this reason that current research efforts focus on making CFI fast and practical. Specifically, much of the work on practical CFI is applicable to binaries, and improves performance by enforcing a looser notion of control flow integrity. In this paper, we examine the security implications of such looser notions of CFI: are they still able to prevent code reuse attacks, and if not, how hard is it to bypass its protection? Specifically, we show that with two new types of gadgets, return oriented programming is still possible. We assess the availability of our gadget sets, and demonstrate the practicality of these results with a practical exploit against Internet Explorer that bypasses modern CFI implementations.</p>
<p>【Keywords】:
 programming; security of data; CFI; Internet Explorer; code reuse attacks; control flow integrity; return oriented programming; Electronic mail; Integrated circuits; Internet; Payloads; Programming; Security; Software; Control-flow integrity evaluation; code-reuse attack</p>
<h3 id="37. Modeling and Discovering Vulnerabilities with Code Property Graphs.">37. Modeling and Discovering Vulnerabilities with Code Property Graphs.</h3>
<p>【<a href="http://dx.doi.org/10.1109/SP.2014.44">Paper Link</a>】    【Pages】:590-604</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/y/Yamaguchi:Fabian">Fabian Yamaguchi</a> ; <a href="http://dblp.uni-trier.de/pers/hd/g/Golde:Nico">Nico Golde</a> ; <a href="http://dblp.uni-trier.de/pers/hd/a/Arp:Daniel">Daniel Arp</a> ; <a href="http://dblp.uni-trier.de/pers/hd/r/Rieck:Konrad">Konrad Rieck</a></p>
<p>【Abstract】:
The vast majority of security breaches encountered today are a direct result of insecure code. Consequently, the protection of computer systems critically depends on the rigorous identification of vulnerabilities in software, a tedious and error-prone process requiring significant expertise. Unfortunately, a single flaw suffices to undermine the security of a system and thus the sheer amount of code to audit plays into the attacker's cards. In this paper, we present a method to effectively mine large amounts of source code for vulnerabilities. To this end, we introduce a novel representation of source code called a code property graph that merges concepts of classic program analysis, namely abstract syntax trees, control flow graphs and program dependence graphs, into a joint data structure. This comprehensive representation enables us to elegantly model templates for common vulnerabilities with graph traversals that, for instance, can identify buffer overflows, integer overflows, format string vulnerabilities, or memory disclosures. We implement our approach using a popular graph database and demonstrate its efficacy by identifying 18 previously unknown vulnerabilities in the source code of the Linux kernel.</p>
<p>【Keywords】:
 computational linguistics; graphs; source code (software); trees (mathematics); Linux kernel; abstract syntax trees; buffer overflows; classic program analysis; code property graphs; computer systems; control flow graphs; data structure; discovering vulnerabilities; error-prone process; format string vulnerabilities; graph traversals; insecure code; integer overflows; memory disclosures; modeling; popular graph database; program dependence graphs; rigorous identification; security breaches; single flaw suffices; source code; Abstracts; Databases; Joints; Kernel; Security; Syntactics; Graph Databases; Static Analysis; Vulnerabilities</p>
<h3 id="38. SoK: Introspections on Trust and the Semantic Gap.">38. SoK: Introspections on Trust and the Semantic Gap.</h3>
<p>【<a href="http://dx.doi.org/10.1109/SP.2014.45">Paper Link</a>】    【Pages】:605-620</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/j/Jain:Bhushan">Bhushan Jain</a> ; <a href="http://dblp.uni-trier.de/pers/hd/b/Baig:Mirza_Basim">Mirza Basim Baig</a> ; <a href="http://dblp.uni-trier.de/pers/hd/z/Zhang:Dongli">Dongli Zhang</a> ; <a href="http://dblp.uni-trier.de/pers/hd/p/Porter:Donald_E=">Donald E. Porter</a> ; <a href="http://dblp.uni-trier.de/pers/hd/s/Sion:Radu">Radu Sion</a></p>
<p>【Abstract】:
An essential goal of Virtual Machine Introspection (VMI) is assuring security policy enforcement and overall functionality in the presence of an untrustworthy OS. A fundamental obstacle to this goal is the difficulty in accurately extracting semantic meaning from the hypervisor's hardware level view of a guest OS, called the semantic gap. Over the twelve years since the semantic gap was identified, immense progress has been made in developing powerful VMI tools. Unfortunately, much of this progress has been made at the cost of reintroducing trust into the guest OS, often in direct contradiction to the underlying threat model motivating the introspection. Although this choice is reasonable in some contexts and has facilitated progress, the ultimate goal of reducing the trusted computing base of software systems is best served by a fresh look at the VMI design space. This paper organizes previous work based on the essential design considerations when building a VMI system, and then explains how these design choices dictate the trust model and security properties of the overall system. The paper then observes portions of the VMI design space which have been under-explored, as well as potential adaptations of existing techniques to bridge the semantic gap without trusting the guest OS. Overall, this paper aims to create an essential checkpoint in the broader quest for meaningful trust in virtualized environments through VM introspection.</p>
<p>【Keywords】:
 information retrieval; security of data; trusted computing; virtual machines; virtualisation; VMI system; semantic gap; semantic meaning extraction; system security; trusted computing base; virtual machine introspection; virtualized environments; Data structures; Kernel; Linux; Monitoring; Security; Semantics; Virtual machine monitors; VM Introspection; semantic gap; trust</p>
<h2 id="Session 10: Secure Computation and Storage    3">Session 10: Secure Computation and Storage    3</h2>
<h3 id="39. Automating Efficient RAM-Model Secure Computation.">39. Automating Efficient RAM-Model Secure Computation.</h3>
<p>【<a href="http://dx.doi.org/10.1109/SP.2014.46">Paper Link</a>】    【Pages】:623-638</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/l/Liu:Chang">Chang Liu</a> ; <a href="http://dblp.uni-trier.de/pers/hd/h/Huang:Yan">Yan Huang</a> ; <a href="http://dblp.uni-trier.de/pers/hd/s/Shi:Elaine">Elaine Shi</a> ; <a href="http://dblp.uni-trier.de/pers/hd/k/Katz:Jonathan">Jonathan Katz</a> ; <a href="http://dblp.uni-trier.de/pers/hd/h/Hicks:Michael_W=">Michael W. Hicks</a></p>
<p>【Abstract】:
RAM-model secure computation addresses the inherent limitations of circuit-model secure computation considered in almost all previous work. Here, we describe the first automated approach for RAM-model secure computation in the semi-honest model. We define an intermediate representation called SCVM and a corresponding type system suited for RAM-model secure computation. Leveraging compile-time optimizations, our approach achieves order-of-magnitude speedups compared to both circuit-model secure computation and the state-of-art RAM-model secure computation.</p>
<p>【Keywords】:
 program compilers; random-access storage; security of data; SCVM; automated RAM-model secure computation approach; compile-time optimizations; intermediate representation; order-of-magnitude speedups; random access machine; Arrays; Computational modeling; Integrated circuit modeling; Program processors; Protocols; Random access memory; Security</p>
<h3 id="40. Dynamic Searchable Encryption via Blind Storage.">40. Dynamic Searchable Encryption via Blind Storage.</h3>
<p>【<a href="http://dx.doi.org/10.1109/SP.2014.47">Paper Link</a>】    【Pages】:639-654</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/n/Naveed_0001:Muhammad">Muhammad Naveed</a> ; <a href="http://dblp.uni-trier.de/pers/hd/p/Prabhakaran:Manoj">Manoj Prabhakaran</a> ; <a href="http://dblp.uni-trier.de/pers/hd/g/Gunter:Carl_A=">Carl A. Gunter</a></p>
<p>【Abstract】:
Dynamic Searchable Symmetric Encryption allows a client to store a dynamic collection of encrypted documents with a server, and later quickly carry out keyword searches on these encrypted documents, while revealing minimal information to the server. In this paper we present a new dynamic SSE scheme that is simpler and more efficient than existing schemes while revealing less information to the server than prior schemes, achieving fully adaptive security against honest-but-curious servers. We implemented a prototype of our scheme and demonstrated its efficiency on datasets from prior work. Apart from its concrete efficiency, our scheme is also simpler: in particular, it does not require the server to support any operation other than upload and download of data. Thus the server in our scheme can be based solely on a cloud storage service, rather than a cloud computation service as well, as in prior work. In building our dynamic SSE scheme, we introduce a new primitive called Blind Storage, which allows a client to store a set of files on a remote server in such a way that the server does not learn how many files are stored, or the lengths of the individual files, as each file is retrieved, the server learns about its existence (and can notice the same file being downloaded subsequently), but the file's name and contents are not revealed. This is a primitive with several applications other than SSE, and is of independent interest.</p>
<p>【Keywords】:
 cloud computing; cryptography; storage management; blind storage; cloud computation service; cloud storage service; dynamic SSE scheme; dynamic searchable symmetric encryption; fully adaptive security; honest-but-curious server security; keyword search; Adaptation models; Cloud computing; Encryption; Privacy; Servers; cloud security; dynamic searchable encryption; secure cloud storage</p>
<h3 id="41. Wysteria: A Programming Language for Generic, Mixed-Mode Multiparty Computations.">41. Wysteria: A Programming Language for Generic, Mixed-Mode Multiparty Computations.</h3>
<p>【<a href="http://dx.doi.org/10.1109/SP.2014.48">Paper Link</a>】    【Pages】:655-670</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/r/Rastogi:Aseem">Aseem Rastogi</a> ; <a href="http://dblp.uni-trier.de/pers/hd/h/Hammer:Matthew_A=">Matthew A. Hammer</a> ; <a href="http://dblp.uni-trier.de/pers/hd/h/Hicks:Michael">Michael Hicks</a></p>
<p>【Abstract】:
In a Secure Multiparty Computation (SMC), mutually distrusting parties use cryptographic techniques to cooperatively compute over their private data, in the process each party learns only explicitly revealed outputs. In this paper, we present Wysteria, a high-level programming language for writing SMCs. As with past languages, like Fairplay, Wysteria compiles secure computations to circuits that are executed by an underlying engine. Unlike past work, Wysteria provides support for mixed-mode programs, which combine local, private computations with synchronous SMCs. Wysteria complements a standard feature set with built-in support for secret shares and with wire bundles, a new abstraction that supports generic n-party computations. We have formalized Wysteria, its refinement type system, and its operational semantics. We show that Wysteria programs have an easy-to-understand single-threaded interpretation and prove that this view corresponds to the actual multi-threaded semantics. We also prove type soundness, a property we show has security ramifications, namely that information about one party's data can only be revealed to another via (agreed upon) secure computations. We have implemented Wysteria, and used it to program a variety of interesting SMC protocols from the literature, as well as several new ones. We find that Wysteria's performance is competitive with prior approaches while making programming far easier, and more trustworthy.</p>
<p>【Keywords】:
 cryptographic protocols; data privacy; high level languages; multi-threading; SMC protocols; Wysteria compiles; Wysteria performance; cryptographic techniques; formalized Wysteria programs; generic n-party computations; high level programming language; mixed mode multiparty computations; mixed-mode programs; multithreaded semantics; operational semantics; private data; refinement type system; secure computations; secure multiparty computation; security ramifications; synchronous SMC; Cryptography; Educational institutions; Protocols; Semantics; Standards; Wires; Writing; Dependent type system; Functional language; Secure multi-party computation</p>
<h2 id="Session 11: Authentication    3">Session 11: Authentication    3</h2>
<h3 id="42. An Expressive Model for the Web Infrastructure: Definition and Application to the Browser ID SSO System.">42. An Expressive Model for the Web Infrastructure: Definition and Application to the Browser ID SSO System.</h3>
<p>【<a href="http://dx.doi.org/10.1109/SP.2014.49">Paper Link</a>】    【Pages】:673-688</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/f/Fett:Daniel">Daniel Fett</a> ; <a href="http://dblp.uni-trier.de/pers/hd/k/K=uuml=sters:Ralf">Ralf Küsters</a> ; <a href="http://dblp.uni-trier.de/pers/hd/s/Schmitz:Guido">Guido Schmitz</a></p>
<p>【Abstract】:
The web constitutes a complex infrastructure and, as demonstrated by numerous attacks, rigorous analysis of standards and web applications is indispensable. Inspired by successful prior work, in particular the work by Akhawe et al. as well as Bansal et al., in this work we propose a formal model for the web infrastructure. While unlike prior works, which aim at automatic analysis, our model so far is not directly amenable to automation, it is much more comprehensive and accurate with respect to the standards and specifications. As such, it can serve as a solid basis for the analysis of a broad range of standards and applications. As a case study and another important contribution of our work, we use our model to carry out the first rigorous analysis of the Browser ID system (a.k.a. Mozilla Persona), a recently developed complex real-world single sign-on system that employs technologies such as AJAX, cross-document messaging, and HTML5 web storage. Our analysis revealed a number of very critical flaws that could not have been captured in prior models. We propose fixes for the flaws, formally state relevant security properties, and prove that the fixed system in a setting with a so-called secondary identity provider satisfies these security properties in our model. The fixes for the most critical flaws have already been adopted by Mozilla and our findings have been rewarded by the Mozilla Security Bug Bounty Program.</p>
<p>【Keywords】:
 Internet; online front-ends; program debugging; security of data; AJAX; HTML5 web storage; Mozilla security bug bounty program; Web applications; Web infrastructure; Web security; automatic analysis; browserID SSO system; cross-document messaging; formal model; formal security analysis; rigorous analysis; secondary identity provider; single sign-on system; state relevant security properties; Analytical models; Browsers; Mathematical model; Security; Standards; Web servers; Formal Security Analysis; Single Sign-on; Web Model; Web Security</p>
<h3 id="43. A Study of Probabilistic Password Models.">43. A Study of Probabilistic Password Models.</h3>
<p>【<a href="http://dx.doi.org/10.1109/SP.2014.50">Paper Link</a>】    【Pages】:689-704</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/m/Ma:Jerry">Jerry Ma</a> ; <a href="http://dblp.uni-trier.de/pers/hd/y/Yang:Weining">Weining Yang</a> ; <a href="http://dblp.uni-trier.de/pers/hd/l/Luo:Min">Min Luo</a> ; <a href="http://dblp.uni-trier.de/pers/hd/l/Li:Ninghui">Ninghui Li</a></p>
<p>【Abstract】:
A probabilistic password model assigns a probability value to each string. Such models are useful for research into understanding what makes users choose more (or less) secure passwords, and for constructing password strength meters and password cracking utilities. Guess number graphs generated from password models are a widely used method in password research. In this paper, we show that probability-threshold graphs have important advantages over guess-number graphs. They are much faster to compute, and at the same time provide information beyond what is feasible in guess-number graphs. We also observe that research in password modeling can benefit from the extensive literature in statistical language modeling. We conduct a systematic evaluation of a large number of probabilistic password models, including Markov models using different normalization and smoothing methods, and found that, among other things, Markov models, when done correctly, perform significantly better than the Probabilistic Context-Free Grammar model proposed in Weir et al., which has been used as the state-of-the-art password model in recent research.</p>
<p>【Keywords】:
 Markov processes; graph theory; probability; security of data; Markov models; guess number graphs; password cracking utilities; password strength meters; probabilistic password models; probability-threshold graphs; secure passwords; statistical language modeling; Computational modeling; Dictionaries; Educational institutions; Markov processes; Probabilistic logic; Testing; Training</p>
<h3 id="44. ZEBRA: Zero-Effort Bilateral Recurring Authentication.">44. ZEBRA: Zero-Effort Bilateral Recurring Authentication.</h3>
<p>【<a href="http://dx.doi.org/10.1109/SP.2014.51">Paper Link</a>】    【Pages】:705-720</p>
<p>【Authors】:
<a href="http://dblp.uni-trier.de/pers/hd/m/Mare:Shrirang">Shrirang Mare</a> ; <a href="http://dblp.uni-trier.de/pers/hd/m/Molina=Markham:Andres">Andres Molina-Markham</a> ; <a href="http://dblp.uni-trier.de/pers/hd/c/Cornelius:Cory">Cory Cornelius</a> ; <a href="http://dblp.uni-trier.de/pers/hd/p/Peterson:Ronald_A=">Ronald A. Peterson</a> ; <a href="http://dblp.uni-trier.de/pers/hd/k/Kotz:David">David Kotz</a></p>
<p>【Abstract】:
Common authentication methods based on passwords, tokens, or fingerprints perform one-time authentication and rely on users to log out from the computer terminal when they leave. Users often do not log out, however, which is a security risk. The most common solution, inactivity timeouts, inevitably fail security (too long a timeout) or usability (too short a timeout) goals. One solution is to authenticate users continuously while they are using the terminal and automatically log them out when they leave. Several solutions are based on user proximity, but these are not sufficient: they only confirm whether the user is nearby but not whether the user is actually using the terminal. Proposed solutions based on behavioral biometric authentication (e.g., keystroke dynamics) may not be reliable, as a recent study suggests. To address this problem we propose Zero-Effort Bilateral Recurring Authentication (ZEBRA). In ZEBRA, a user wears a bracelet (with a built-in accelerometer, gyroscope, and radio) on her dominant wrist. When the user interacts with a computer terminal, the bracelet records the wrist movement, processes it, and sends it to the terminal. The terminal compares the wrist movement with the inputs it receives from the user (via keyboard and mouse), and confirms the continued presence of the user only if they correlate. Because the bracelet is on the same hand that provides inputs to the terminal, the accelerometer and gyroscope data and input events received by the terminal should correlate because their source is the same - the user's hand movement. In our experiments ZEBRA performed continuous authentication with 85% accuracy in verifying the correct user and identified all adversaries within 11s. For a different threshold that trades security for usability, ZEBRA correctly verified 90% of users and identified all adversaries within 50s.</p>
<p>【Keywords】:
 accelerometers; authorisation; gyroscopes; human computer interaction; interactive terminals; message authentication; ZEBRA; authentication methods; behavioral biometric authentication; built-in accelerometer; computer terminal; fingerprints; gyroscope; inactivity timeouts; keystroke dynamics; one-time authentication; passwords; radio; security risk; tokens; user bracelet; user hand movement; user interaction; user proximity; users authentication; wrist movement; zero-effort bilateral recurring authentication; Accelerometers; Authentication; Gyroscopes; Keyboards; Mice; Wrist; continuous authentication; deauthentication; security; usability; wearable</p>
 

<div class="home">
<i title='主页' onclick="location.href='../index.html'"><i class="fa fa-home fa-lg"></i></i>
</div>

<div class="toc">
<i id="showLeftPush" title='目录'><i class="fa fa-list fa-lg"></i></i>
</div>

<!-- Classie - class helper functions by @desandro https://github.com/desandro/classie -->
<script>
	var menuLeft = document.getElementById( 'menu-s1' ),
		showLeftPush = document.getElementById( 'showLeftPush' ),
		body = document.body;

	showLeftPush.onclick = function() {
		classie.toggle( this, 'active' );
		classie.toggle( body, 'cbp-spmenu-push-toright' );
		classie.toggle( menuLeft, 'cbp-spmenu-open' );
		disableOther( 'showLeftPush' );
	};
</script>

<div class="go-top" >
<i title='顶部' onclick="window.scrollTo('0', '0')"><i class="fa fa-angle-double-up fa-2x"></i></i>
</div>


<div class="theme" >
<i title='主题' onclick="setStyle()"><i class="fa fa-adjust fa-lg"></i></i>
</div>

<!-- 更换theme -->
<script type="text/javascript">
function setStyle(){ 
    if(document.getElementById("dark").disabled){
        document.getElementById("light").disabled = true; 
        document.getElementById("dark").disabled = false; 
        }
    else{
        document.getElementById("dark").disabled = true; 
        document.getElementById("light").disabled = false; 
        }
    }
</script>


<div id="footer">

  <p> <i class="fa fa-envelope-o fa-1x"></i>:&nbsp huntercmd@163.com &nbsp Published under<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/3.0/deed.zh"> (CC) BY-NC-SA 3.0</a></p>

  <p>&copy; 2013 HunterCmd &nbsp <a href="http://huntercmd.github.io"><i class="fa fa-github fa-1x"></i>
  </p>
</div>

</body>
